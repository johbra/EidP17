<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8"/>
<title>Datenabstraktion</title>
<meta name="author" content="Johannes Brauer"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="reveal.js-master/dist/reveal.css"/>

<link rel="stylesheet" href="reveal.js-master/dist/theme/simple.css" id="theme"/>

<link rel="stylesheet" href="./mycss/myrevealstyle.css"/>
<link rel="stylesheet" href="reveal.js-master/plugin/highlight/vs.css"/>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<link rel="stylesheet" type="text/css" href="mycss/mystyle.css" />
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide">
<h1 class="title">Datenabstraktion</h1><h3 class="subtitle">Einführung in die Programmierung</h3><h2 class="author">Johannes Brauer</h2><h3 class="date">22. 11. 2020</h3>
</section>

<section>
<section id="slide-orgb0626f2">
<h2 id="orgb0626f2">Zusammengesetzte Datenstrukturen</h2>
<ul>
<li>Im Abschnitt über die Verwendung von Hilfsfunktionen wurde der
Begriff der <i>prozeduralen Abstraktion</i> geprägt: Eine Funktion kann
unter Verwendung von Hilfsfunktionen entwickelt werden, ohne die
Details ihrer Implementierung kennen zu müssen. Davon kann
abstrahiert werden.</li>
<li><i>Datenabstraktion</i> ermöglicht mit zusammengesetzten Daten
(Datenstrukturen) zu arbeiten, ohne wissen zu müssen, wie sie aus
primitiveren Datenobjekten konstruiert werden.</li>

</ul>
</section>
<section id="slide-orga1ca5de">
<h3 id="orga1ca5de">Datenabstraktion</h3>
<ul>
<li>Grundgedanke: Einzelne Dinge werden zu einem neuen Ganzen. 
<ul>
<li>Aus 5000 Einzelteilen entsteht ein Auto.</li>
<li>Aus zwei Keksen und Schokocreme entsteht ein Waffelkeks.</li>
<li>Aus zwei Koordinaten entsteht ein Punkt.</li>
<li>Aus einer Menge von Merkmalen entsteht eine Objektstruktur.</li>

</ul></li>

</ul>

</section>
<section id="slide-org9eb8e72">
<h3 id="org9eb8e72">Beispiel: Rechnen mit Punkten in der Ebene</h3>
<ul>
<li>In den bisherigen Beispielen wurden nur Funktionen betrachtet, die
atomare Daten (Zahlen) verarbeiten.</li>
<li>Jetzt rechnen wir mit Punkten in der Ebene</li>

</ul>

</section>
<section id="slide-org1d91272">
<h4 id="org1d91272">Defintion von Punkten</h4>
<ul>
<li>Ein Punkt in der Ebene wird durch seine x- und seine y-Koordinate
bestimmt (kartesisches Koordinatensystem).</li>
<li><p>
Wir tun so, als ob wir eine Funktion <code>make-point</code> zur Verfügung
hätten, die einen Punkt erzeugt, z. B. so:
</p>
<pre class="example">
(make-point 3 4)
</pre></li>
<li><p>
Nehmen wir weiter an, es gäbe zwei Funktionen, die die x- bzw. die
y-Koordinate eines Punkts zugänglich macht:
</p>
<pre class="example">
(point-x (make-point 3 4)) ;;=&gt; 3
(point-y (make-point 3 4)) ;;=&gt; 4
</pre></li>

</ul>
</section>
<section id="slide-org606ad4e">
<h4 id="org606ad4e">Punkt-Funktionen</h4>
<ul>
<li><p>
Unter diesen Voraussetzungen könnte eine Funktion zur Addition
zweier Punkte wie folgt definiert werden:
</p>
<div class="org-src-container">

<pre><code class="scheme" >  (define add-point
    (lambda [p1 p2]
      (make-point
        (+ (point-x p1) (point-x p2))
        (+ (point-y p1) (point-y p2)))))
</code></pre>
</div></li>

</ul>
</section>
<section>
<ul>
<li><p>
Weitere <code>point</code>-Funktionen könnten sein:
</p>
<div class="small">
<div class="org-src-container">

<pre><code class="scheme" >  (define equal-point?
    (lambda [p1 p2]
      (and (= (point-x p1) (point-x p2))
           (= (point-y p1) (point-y p2)))))
  
  (define distance-to-0
    (lambda [p]
      (sqrt (+ (sqr (point-x p)) (sqr (point-y p))))))
</code></pre>
</div>

</div></li>

<li>Diese (und weitere) Funktionen können programmiert werden, ohne
<ul>
<li>die Funktionen <code>make-point</code>, <code>point-x</code> und <code>point-y</code> implementiert
zu haben und</li>
<li>eine konkrete Repräsentation von Punkten angegeben zu haben.</li>

</ul></li>

</ul>
</section>
<section id="slide-orgabee166">
<h4 id="orgabee166">Implementierung der Datenstruktur durch <code>pairs</code></h4>
<p>
<b>Anmerkung:</b> Die hier gezeigte Implementierung funktioniert nicht in
den Lehrsprachen von DrRacket.
</p>

<ul>
<li>Racket stellt eine einfache, aus zwei Komponenten bestehende
Verbundstruktur &#x2013; genannt <code>pair</code> &#x2013; zur Vefügung.</li>
<li>Ein <code>pair</code> kann mithilfe der Funktion <code>cons</code> erzeugt werden.</li>
<li><code>cons</code> erwartet zwei Argumente und gibt ein zusammengesetztes
Datenobjekt zurück, das die beiden Argumente als Teile enthält.
Beispiel: <code>(cons 3 4)</code> liefert <code>(3 . 4)</code></li>
<li><p>
Für den Zugriff auf die beiden Teile eines <code>pairs</code> gibt es die
beiden Funktionen <code>car</code> und <code>cdr</code>:
</p>
<pre class="example">
(car (cons 1 2)) ;;=&gt; 1
(cdr (cons 1 2)) ;;=&gt; 2
</pre></li>

</ul>
</section>
<section id="slide-org5c22b57">
<h4 id="org5c22b57">Die Funktionen <code>make-point</code>, <code>point-x</code> und <code>point-y</code></h4>
<ul>
<li><code>make-point</code> heißt auch Konstruktionsfunktion.</li>
<li><code>point-x</code> und <code>point-y</code> nennt man auch Selektionsfunktionen.</li>

</ul>
<div class="org-src-container">

<pre><code class="scheme" > (define make-point
   (lambda [x y] (cons x y)))

 (define point-x
   (lambda [p] (car p)))

 (define point-y
   (lambda [p] (cdr p)))
</code></pre>
</div>
</section>
<section id="slide-org55ad704">
<h4 id="org55ad704">Abstraktionsbarrieren</h4>

<div class="figure">
<p><img src="./Abbildungen/barrieren.png" alt="barrieren.png" width="400px" />
</p>
</div>
</section>
<section id="slide-org21be6da">
<h4 id="org21be6da">Nutzen der Abstraktion</h4>
<ul>
<li>Programm leichter pflegbar</li>
<li>Komplexe Datenstrukturen können auf verschieden Arten unter
Verwendung der von der Programmiersprache bereitgestellten
primitiven Strukturen implementiert werden.</li>
<li>Die Implementierung mithilfe von <code>pairs</code> erfordert allerdings für
jede neu zu definierende Datenstruktur die erneute Implementierung
von Konstruktions- und Selektionsfunktionen. („boiler plate code”)</li>
<li>Deshalb sehen Programmiersprachen häufig komfortablere Möglichkeiten
vor, Datenstrukturen zu definieren.</li>

</ul>

</section>
<section id="slide-org3efa6d9">
<h3 id="org3efa6d9">Definition von Strukturen in Racket</h3>
<ul>
<li>Sprache: DrRacket-Lehrsprache „Zwischenstufe mit lambda”</li>
<li>Für die Definition von Strukturen (Verbünde, records) steht die
Pseudofunktion <code>define-struct</code> zur Verfügung.</li>
<li>Punkte im zweidimensionalen, kartesischen Koordinatensystem (s. o.)
könnten wie folgt definiert werden:
<code class="src src-scheme"><span style="color: #707183;">(</span>define-struct point <span style="color: #7388D6;">[</span>x y<span style="color: #7388D6;">]</span><span style="color: #707183;">)</span></code></li>
<li>Mit dieser Definition stehen automatisch die folgenden Funktionen
bereit:
<ul>
<li><code>make-point</code> : akzeptiert zwei Zahlen als Argumente und erzeugt
ein neues Exemplar der Struktur <code>point</code>.</li>
<li><code>point-x</code> : akzeptiert ein Exemplar der Struktur <code>point</code> und
liefert die <code>x</code>-Komponente.</li>
<li><code>point-y</code> : akzeptiert ein Exemplar der Struktur <code>point</code> und
liefert die <code>y</code>-Komponente.</li>
<li><code>point?</code> : akzeptiert einen beliebigen Wert als Argument und
liefert <code>#true</code>, falls der Wert ein Exemplar der Struktur <code>point</code>
ist.</li>

</ul></li>

</ul>
</section>
<section id="slide-orgdc07863">
<h4 id="orgdc07863">Benutzungsbeispiel in DrRacket</h4>
<pre class="example">
Willkommen bei DrRacket, Version 6.7 [3m].
Sprache: Zwischenstufe mit lambda; memory limit: 128 MB.
&gt; (define-struct point [x y])
&gt; (define p1 (make-point 3 4))
&gt; p1
(make-point 3 4)
&gt; (point-x p1)
3
&gt; (point-y p1)
4
&gt; (point? p1)
#true
&gt; (point? "p1")
#false
&gt; 
</pre>
</section>
<section id="slide-orgcddaa40">
<h4 id="orgcddaa40">Weiterverwendung von <code>add-point</code> &#x2026;</h4>
<p class="backwardlink">
Die in Abschnitt <a href="#/slide-org606ad4e" class="backwardlink">Punkt-Funktionen</a> eingeführten Funktionen
</p>
<div class="org-src-container">

<pre><code class="scheme" >  (define add-point
    (lambda [p1 p2]
      (make-point
        (+ (point-x p1) (point-x p2))
        (+ (point-y p1) (point-y p2)))))
  (define equal-point?
    (lambda [p1 p2]
      (and 
       (= (point-x p1) (point-x p2))
       (= (point-y p1) (point-y p2)))))
  (define distance-to-0
    (lambda [p]
      (sqrt
       (+ (sqr (point-x p))
          (sqr (point-y p))))))
</code></pre>
</div>
<p>
können unverändert bleiben.
</p>
</section>
<section id="slide-org902c64c">
<h4 id="org902c64c">Regel (7) für das Aufschreiben von Strukturdefinitionen</h4>
<ul>
<li>Für den Entwurf einer zusammengesetzten Datenstruktur ist es
hilfreich, ihre Zusammensetzung durch einen Kommentar genau zu beschreiben.</li>
<li>Anschließend erfolgt der passende Aufruf von <code>define-struct</code></li>
<li><p>
Beispiel:
</p>
<div class="org-src-container">

<pre><code class="scheme" >  ;; Ein Rechteck ist ein Wert
  ;;  (make-rectangle a b)
  ;; wobei a und b Zahlen sind, die die Seitenlängen eines Rechecks beschreiben.
  : (define-struct rectangle [a b])
</code></pre>
</div></li>

</ul>
</section>
<section>
<p>
<b>Regel 7 (Datenstrukturen)</b>
</p>
<ol>
<li>Finde durch die Datenanalyse heraus, aus welchen Komponenten die
Datenstruktur besteht.</li>
<li>Schreibe dann die Datendefinition in der Form auf:<br />
; Ein \(s\) ist ein Wert<br />
; (make-s <i>s<sub>1</sub></i> &#x2026; <i>s<sub>n</sub></i>)<br />
; wobei <i>s<sub>1</sub></i> &#x2026;</li>
<li>Definiere die Datenstruktur:<br />
(define-struct \(s\) [\(s_1\) &#x2026;])</li>

</ol>
</section>
<section id="slide-org1e1ff16">
<h3 id="org1e1ff16">Entwicklungsmethodik für strukturverarbeitende Funktionen</h3>
<p>
<b>Regel 8 (strukturverarbeitende Funktionen)</b>
</p>

<ol>
<li>Bestimme die für die Berechnung des Ergebnisses
erforderlichen Komponenten der Datenstruktur!</li>
<li>Für jede Komponente der Datenstruktur, von deren Wert das Ergebnis
der Funktion abhängt, schreibe den zugehörigen Selektor in die
Funktionsschablone.</li>
<li>Falls die Funktion eine Datenstruktur als Resultat liefern muss,
nimm den Aufruf des Konstruktors in die Schablone mit auf.</li>

</ol>

</section>
<section id="slide-org7853237">
<h4 id="org7853237">Anwendungsbeispiele für Regel 8</h4>
<p>
Für die Funktion <code>add-point</code> ergäbe sich damit die folgenden Schablone:
</p>
<div class="small">
<div class="org-src-container">

<pre><code class="scheme" >(define add-point
      (lambda [p1 p2]
         (make-point
            (... (point-x p1) (point-x p2)...
             ... (point-y p1) (point-y p2)...))))
</code></pre>
</div>

</div>

<p>
Für die Funktion <code>equal-point?</code> ergäbe sich eine Schablone ohne Konstruktor:
</p>
<div class="org-src-container">

<pre><code class="scheme" >(define equal-point?
      (lambda [p1 p2]
         (...
            (... (point-x p1) (point-x p2)...
             ... (point-y p1) (point-y p2)...))))
</code></pre>
</div>

</section>
<section id="slide-org2f46150">
<h4 id="org2f46150">Regel-konforme Aufschreibung der Funktionen <code>equal-point?</code> und <code>add-point</code></h4>
<div class="outline-text-4" id="text-org2f46150">
</div>
</section>
<section id="slide-orgcaf48c6">
<h5 id="orgcaf48c6"><code>equal-point?</code></h5>
<div class="org-src-container">

<pre><code class="scheme" >;; ein Punkt ist ein Wert
;;   (make-point x y)
;; wobei x und y Zahlen sind und die kartesischen Koordinaten
;; eines Punkts in der Ebene darstellen.
(define-struct point [x y])

;; prüft zwei Punkte auf Gleichheit, die durch die Gleichheit
;; der x- und der y-Koordinaten gegeben ist.
(define equal-point?
  (lambda [p1 p2]
    (and 
     (= (point-x p1) (point-x p2))
     (= (point-y p1) (point-y p2)))))
;; Beispielanwendungen:
(not (equal-point? (make-point 2 3) (make-point 5 1)))
(equal-point? (make-point 2 3) (make-point 2 3))
</code></pre>
</div>
</section>
<section id="slide-org8213c01">
<h5 id="org8213c01"><code>add-point</code></h5>
<div class="org-src-container">

<pre><code class="scheme" >;; Berechnung eines neuen Punktes durch die Addition zweier Punkte
(define add-point
  (lambda [p1 p2]
    (make-point
     (+ (point-x p1) (point-x p2))
     (+ (point-y p1) (point-y p2)))))
;; Beispielanwendungen:
(equal-point? (add-point (make-point 2 3) (make-point 5 1)) (make-point 7 4))
</code></pre>
</div>
</section>
</section>
<section>
<section id="slide-orga6b72bb">
<h2 id="orga6b72bb">Formulierung von Tests</h2>
<div class="outline-text-2" id="text-orga6b72bb">
</div>
</section>
<section id="slide-orge980749">
<h3 id="orge980749">Tests statt Beispielanwendungen</h3>
<ul>
<li>Man beachte, dass Formulierung der Beispielanwendungen für die
Funktion <code>add-point</code> die Existenz der Funktion <code>equal-point?</code> voraussetzt.</li>
<li>Ohne diese Funktion wäre das Aufschreiben der Beispielanwendungen
erheblich umständlicher.</li>
<li>Die Pseudofunktion <code>define-struct</code> erzeugt leider kein
Gleichheisprädikat automatisch.</li>
<li>Racket bietet aber die Möglichkeit Testprozeduren anstelle von
Beispielanwendungen zu benutzen.</li>

</ul>
</section>
<section id="slide-orgbe0b787">
<h3 id="orgbe0b787">Die Funktion <code>add-point</code> mit Tests</h3>
<ul>
<li>Statt des selbst definierten Gleichheitsprädikats <code>equal-point?</code>
verwenden wir für den Test die Standard-Testprozedur <code>check-expect</code>.</li>
<li><code>check-expect</code> erwartet zwei Argumente:
<ol>
<li>den zu testenden Ausdruck</li>
<li>den Erwartungswert</li>

</ol></li>

</ul>
<div class="org-src-container">

<pre><code class="scheme" >;; ein Punkt ist ein Wert
;;   (make-point x y)
;; wobei x und y Zahlen sind und die kartesischen Koordinaten
;; eines Punkts in der Ebene darstellen.
(define-struct point [x y])

;; Berechnung eines neuen Punktes durch die Addition zweier Punkte
(define add-point
  (lambda [p1 p2]
    (make-point
     (+ (point-x p1) (point-x p2))
     (+ (point-y p1) (point-y p2)))))
;; Tests:
(check-expect (add-point (make-point 2 3) (make-point 5 1)) (make-point 7 4))
</code></pre>
</div>
</section>
<section>
<ul>
<li>Betätigt man nun den Start-Knopf von DrRacket, erscheint im
Interaktionsfenster:</li>

</ul>
<pre class="example">
Willkommen bei DrRacket, Version 6.7 [3m].
Sprache: Zwischenstufe mit lambda; memory limit: 128 MB.
Der eine Test ist bestanden!
&gt; 
</pre>
</section>
<section id="slide-org88bf71e">
<h3 id="org88bf71e">Testfälle in Racket</h3>
<dl>
<dt>(check-expect expr expr)</dt><dd>Dieser Testfall überprüft, ob der erste
expr den gleichen Wert hat wie der zweite expr, wobei das zweite
expr meist ein Literal ist.</dd>
<dt>(check-within expr expr expr)</dt><dd>Wie
check-expect, aber mit einem weiteren Ausdruck, der als Wert eine
Zahl delta hat. Dieser Testfall überprüft, dass jede Zahl im Resultat
des ersten expr maximal um delta von der entsprechenden Zahl im
zweiten expr abweicht.</dd>
<dt>(check-member-of expr expr &#x2026;)</dt><dd>Ähnlich wie
check-expect: Der Testfall überprüft, dass das Resultat des ersten
Operanden gleich dem Wert eines der folgenden Operanden ist.</dd>
<dt>(check-range expr expr expr)</dt><dd>Ähnlich wie check-expect: Alle drei
Operanden müssen Zahlen sein. Der Testfall überprüft, ob die erste
Zahl zwischen der zweiten und der dritten liegt (inklusive).</dd>
<dt>(check-error expr expr)</dt><dd>Dieser Testfall überprüft, ob der erste expr
einen Fehler produziert, wobei die Fehlermeldung der Zeichenkette
entspricht, die der Wert des zweiten expr ist.</dd>

</dl>

</section>
<section id="slide-org028ff48">
<h3 id="org028ff48">Modifikation der Regel 3</h3>
<p>
<b>Regel 3neu</b>
</p>

<p>
Schreibe Tests für die Funktion unter Verwendung der
<code>check-...</code>-Prozeduren von Racket auf.
</p>

<p>
Es ist üblich, die Tests zwischen die Zweckbestimmung und die Funktion
zu schreiben.
</p>

</section>
<section id="slide-org4da50c0">
<h4 id="org4da50c0">Anwendung auf die Funktion <code>distance-to-0</code></h4>
<div class="org-src-container">

<pre><code class="scheme" >;; ein Punkt ist ein Wert
;;   (make-point x y)
;; wobei x und y Zahlen sind und die kartesischen Koordinaten
;; eines Punkts in der Ebene darstellen.
(define-struct point [x y])

;; berechnet den Abstand eines Punktes vom Ursprung des
;; Koordinatensystems
(check-within (distance-to-0 (make-point 2 2)) (sqrt 8) 0.01)
(check-within (distance-to-0 (make-point (sqrt 8) (sqrt 8))) 4 0.01)
(define distance-to-0
  (lambda [p]
    (sqrt
     (+ (sqr (point-x p))
        (sqr (point-y p))))))
</code></pre>
</div>
<p>
<b>Frage:</b> Warum brauchen wir hier die Testprozedur <code>check-within</code>?
</p>

<p>
(Aufgaben zu Datenstrukturen)
</p>

</section>
</section>
<section>
<section id="slide-orgba9323b">
<h2 id="orgba9323b">Gemischte Daten</h2>
<div class="outline-text-2" id="text-orgba9323b">
</div>
</section>
<section id="slide-orge4845ba">
<h3 id="orge4845ba">Datenabstraktion durch Generalisierung</h3>
<ul>
<li>Funktionen sollen verschiedene &#x2013; aber verwandte &#x2013; Datenstrukturen
verarbeiten.</li>

<li><p>
Beispiel: Rechtecke und Kreise sind geometrische Figuren.
</p>

<div class="small">
<div class="org-src-container">

<pre><code class="scheme" >    ;; Eine Figur ist entweder
    ;; - ein Rechteck oder
    ;; - ein Kreis
    ;; Name: shape
</code></pre>
</div>

</div></li>
<li>Für <code>shapes</code>-verarbeitende Funktionen sind nur die
Datenstrukturdefinitionen für Rechtecke und Kreise erforderlich.</li>

</ul>

</section>
<section id="slide-orgdaedd14">
<h3 id="orgdaedd14">Definition von <code>rectangle</code></h3>
<div class="org-src-container">

<pre><code class="scheme" >;; Eine Rechteck ist ein Wert 
;;   (make-rectangle h w)
;; wobei h eine Zahl für die Höhe, 
;;       w eine Zahl für die Breite
;; des Rechtecks ist
(define-struct rectangle [h w])

;; Rechteckfläche berechnen
(check-within (rect-area (make-rectangle 2.5 3.0)) 7.5 0.01)
(define rect-area
  (lambda [r]
    (* (rectangle-h r) (rectangle-w r))))
</code></pre>
</div>

</section>
<section id="slide-org80839c1">
<h3 id="org80839c1">Definition von <code>circle</code></h3>
<div class="org-src-container">

<pre><code class="scheme" >;; Ein Kreis ist ein Wert
;;    (make-cicle r)
;; wobei r eine Zahl für den Radius ist.
(define-struct circle [r])

;; Kreisfläche berechnen
(check-within (circle-area (make-circle 1.0)) pi 0.01)
(define circle-area
  (lambda [r]
    (* (circle-r r) (circle-r r) pi)))
</code></pre>
</div>

</section>
<section id="slide-orgba0428d">
<h3 id="orgba0428d">Flächeninhalt von Figuren</h3>
<div class="org-src-container">

<pre><code class="scheme" >;; Eine Figur ist entweder
;; - ein Rechteck oder
;; - ein Kreis
;; Name: shape

;; Flächeninhalt einer Figur berechnen
(check-within (shape-area (make-circle 1.0)) pi 0.01)
(check-within (shape-area (make-rectangle 2.5 3.0)) 7.5 0.01)
(define shape-area
  (lambda [s]
    (cond
      [(circle? s)    (circle-area s)]
      [(rectangle? s) (rect-area s)])))
</code></pre>
</div>

</section>
<section id="slide-orgec0dc0a">
<h3 id="orgec0dc0a">Entwurfsmethodik für Funktionen zur Verarbeitung gemischter Daten</h3>
<p>
<b>Regel 9 (Funktionen für gemischte Daten)</b>  
</p>

<ol>
<li>Wenn sich bei der Datenanalyse herausstellt, dass
gemischte Daten zu verarbeiten sind, schreibe zunächst eine
Datendefinition in der Form auf:<br />
;; Ein \(s\) ist entweder<br />
;; - ein \(t_1\) oder<br />
;; - \(\ldots\) oder<br />
;; - ein \(t_n\) <br />
;; Name: x</li>
<li>Für eine \(s\) -verarbeitende Funktion ist mindestens je ein Testfall
für jede Variante von \(s\) aufzuschreiben.</li>

</ol>
</section>
<section>
<ol>
<li value="3"><p>
Seien <code>t1?</code>, <code>t2?</code>, &#x2026;, <code>tn?</code> die Prädikate zu den in \(s\)
vorkommenden Varianten \(t_1, t_2, \ldots, t_n\). Dann ergibt
sich für eine \(s\) -verarbeitende Funktion die folgende Funktionsschablone:
</p>
<pre class="example">
    (check-... )
    ...
    (check-... )
    (define f
      (lambda [x]
        (cond
           [(t1? x) ...]
           [(t2? x) ...]
           ...
           [(tn? x) ...])))
</pre></li>

</ol>
<p>
(Aufgaben zu gemischten Daten)
</p>
</section>
</section>
</div>
</div>
<script src="reveal.js-master/dist/reveal.js"></script>
<script src="reveal.js-master/plugin/highlight/highlight.js"></script>
<script src="reveal.js-master/plugin/zoom/zoom.js"></script>
<script src="reveal.js-master/plugin/search/search.js"></script>
<script src="reveal.js-master/plugin/menu/menu.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: true,
slideNumber: 'c',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: true,
hashOneBasedIndex: false,
pdfSeparateFragments: true,

overview: true,
width: 1120,
height: 800,
margin: 0.05,

transition: 'slide',
transitionSpeed: 'default',

// Plugins with reveal.js 4.x
plugins: [ RevealHighlight, RevealZoom, RevealSearch, RevealMenu ],

// Optional libraries used to extend reveal.js
dependencies: [
]

,menu: {hideMissingTitles: true, markers: false, themes: true }});
</script>
</body>
</html>
