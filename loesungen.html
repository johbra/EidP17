% Created 2020-02-20 Thu 17:45
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage[greek, ngerman, germanb]{babel}
\usepackage{hyperref}
\usepackage{minted}
\author{Johannes Brauer}
\date{\today}
\title{Aufgaben\\\medskip
\large Einführung in die Programmierung}
\hypersetup{
 pdfauthor={Johannes Brauer},
 pdftitle={Aufgaben},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 25.3.50.1 (Org mode 9.3.2)}, 
 pdflang={Germanb}}
\begin{document}

\maketitle
\tableofcontents


\section{Erste Schritte in Racket}
\label{sec:org6c122ce}
Machen Sie sich mit den NORDAKADEMIE-Rechnern vertraut und richten Sie
Ihren Arbeitsplatz ein (Mail, Webbrowser, Verzeichnisse für die
Vorlesungen usw.).  

Finden und starten Sie DrRacket nach den Anweisungen in der Vorlesung.
Werten Sie einen ersten Ausdruck aus, z. B. (* 6 7). 

Welche Funktion haben die Buttons? Welche Menü-Befehle verstehen Sie
schon?

Schauen Sie sich in einem Webbrowser die Seiten zu Racket unter
\url{https://racket-lang.org/} an. Wo finden Sie Hilfe zur Bedienung von
DrRacket? Wie können Sie sich über die Sprache Racket informieren? Wo
finden Sie alle vordefinierten mathematischen Funktionen?

\section{Auswertung arithmetischer Ausdrücke}
\label{sec:org2aea6f0}
\begin{enumerate}
\item Wie wird der Ausdruck\\
\texttt{(* (+ 2 2) (/ (* (+ 3 5) (/ 30 10)) 2))} \\
ausgewertet?
\item Experimentieren Sie mit verschiedenen Operatoren und Zahlenarten.
\item Werten Sie die folgenden Ausdrücke aus und vergleichen Sie die Resultate:
\begin{verbatim}
(- 1.0 0.9)
(- 1000.0 999.9) 
(- #i1000.0 #i999.9)
\end{verbatim}
\end{enumerate}

\section{Aufschreiben elementarer Funktionen}
\label{sec:org72b45bc}
Schreiben Sie für die folgenden mathematischen Formeln Racket-Funktions\-definitionen auf:

\begin{enumerate}
\item \(n^2 + 1\)
\begin{minted}[]{scheme}
      (define fa
        (lambda [n]
          (+ (* n n) 1)))
\end{minted}
\item \(\frac{1}{2}n^2 + 3\)
\begin{minted}[]{scheme}
      (define fb
        (lambda [n]
          (+ (/ (* n n) 2) 3)))
\end{minted}
\item \(2 - \frac{1}{n}\)
\begin{minted}[]{scheme}
      (define fc
        (lambda [n]
          (- 2 (/ 1 n))))
\end{minted}
\end{enumerate}
Geben Sie die Racket-Funktionen in das Definitionsfenster von
DrRacket ein. Geben Sie anschließend in das Interaktionsfenster
Funktionsaufrufe für diese Funktionen ein.
\section{Aufschreiben elementarer Funktionen}
\label{sec:org7500e9f}
In der Praxis findet der Programmierer selten mathematische Formeln
   vor. Aufgabenstellungen sind eher als Prosatext gegeben. Die
   Berechnungsformeln muss er selbst entwickeln durch 
\begin{itemize}
\item eigenes Nachdenken,
\item Nachschlagen in geeigneten Quellen oder
\item Nachfragen beim Auftraggeber.
\end{itemize}
Finden Sie für die folgenden Aufgabenstellungen die passenden
   Formeln und schreiben Sie diese als Funktionsdefinitionen in
   \emph{Racket} auf: 
\begin{enumerate}
\item Berechnung des Rauminhalts eines Quaders aus dessen Länge, Breite und Höhe.  
\begin{minted}[]{scheme}
      (define quader-volumen
        (lambda [laenge breite hoehe]
          (* laenge breite hoehe)))
\end{minted}
\item Schreiben Sie eine Funktion, die aus der Entfernung und der
Geschwindigkeit zweier Züge die Zeit ermittelt, nach der die
Züge sich treffen, wenn Sie sich auf einem gemeinsamen
Streckenabschnitt von ihren jeweiligen Startpunkten aus
aufeinander zu bewegen. 
\begin{minted}[]{scheme}
      (define zug-treffen
        (lambda [entfernung geschwndgkt1 geschwndgkt2]
          (/ entfernung (+ geschwndgkt1 geschwndgkt2))))
\end{minted}
\item Berechnung der Miete, die eine andere Spielerin in Monopoly
bezahlen muss, falls sie auf einen Bahnhof trifft, der einer
anderen Spielerin gehört. Die Miete ist davon abhängig wie viele
Bahnhöfe der anderen Spielerin gehören:
\begin{center}
\begin{tabular}{rr}
Anzahl der Bahnhöfe & Miete\\
\hline
1 & 500\\
2 & 1000\\
3 & 2000\\
4 & 4000\\
\end{tabular}
\end{center}
Hinweis: Ein Aufruf \texttt{(expt x y)} liefert \(x^y\) als Ergebnis.
\begin{minted}[]{scheme}
      (define bahnhofsmiete
        (lambda [anzahl-bahnhoefe]
          (* 500 (expt 2 (- anzahl-bahnhoefe 1)))))
\end{minted}
\end{enumerate}

\section{Anwenden der Aufschreibregeln}
\label{sec:orgc6cf553}
Schreiben Sie die Funktion zur Berechnung der Bahnhofsmiete in
Monopoly (s. o.) gemäß den Regeln 1 bis 3 aus der Vorlesung auf.
\begin{minted}[]{scheme}
;; berechnet die Bahnhofsmiete aus der Anzahl der Bahnhöfe
(define bahnhofsmiete
  (lambda [anzahl-bahnhoefe]
    (* 500 (expt 2 (- anzahl-bahnhoefe 1)))))
;; Beispielanwendungen
(= (bahnhofsmiete 4) 4000)
(= (bahnhofsmiete 3) 2000)
(= (bahnhofsmiete 2) 1000)
(= (bahnhofsmiete 1)  500)
\end{minted}

\textbf{Wenn nichts anderes angeben ist, sind auch die Funktionen für die
folgenden Aufgaben gemäß diesen Regeln aufzuschreiben!!!}

\section{Profit für den Kinobesitzer}
\label{sec:org7a72965}
Ein altmodisches Vorstadtkino besitzt eine einfache Formel für die
Berechnung des Profits einer Vorstellung: Jeder Kinobesucher
bezahlt 500 Währungseinheiten für die Eintrittskarte. Jede
Vorstellung kostet das Kino 2000 Währungseinheiten plus 50
Währungseinheiten pro Besucher. Schreiben Sie eine Funktion \texttt{profit} zur
Berechnung des Profits bei gegebener Besucherzahl.
\begin{minted}[]{scheme}
;; berechnet den Profit eine Filmvorfuehrung aus 2000 WE Fixkosten
;; und 50 WE Kosten pro Besucher bei gegebener Besucherzahl und
;; 500 WE Kartenpreis
(define profit
  (lambda [besucherzahl]
    (- (* 500 besucherzahl)
       (+ (* 50 besucherzahl) 2000))))
;; Beispielanwendungen
(= (profit 100) 43000)
\end{minted}
\section{Modifikation von \texttt{kino.rkt}}
\label{sec:orgb96a3ae}
\begin{enumerate}
\item Modifizieren Sie das Programm \texttt{kino.rkt} so, dass die Fixkosten
einer Veranstaltung wegfallen und dafür 15 Währungseinheiten pro
Besucher an Kosten anfallen.
\item Nehmen Sie die gleiche Modifikation auch an der Funktion \texttt{profit}
aus der Vorlesung vor, die ohne Hilfsfunktionen auskommt, und
vergleichen Sie die Ergebnisse.
\end{enumerate}

\section{Einsatz von Hilfsfunktionen}
\label{sec:orgca37c63}
Die folgenden Aufgaben sind unter Benutzung von Hilfsfunktionen zu
lösen. Befolgen Sie unbedingt alle in der Vorlesung angegebenen Regeln:
\begin{enumerate}
\item Schreiben Sie ein Programm, das das Volumen eines Zylinders zu
berechnen erlaubt. Eingangsgrößen sind der Radius und die Höhe des Zylinders.
\item Schreiben Sie ein Programm, das die Oberfläche eines Zylinders zu
berechnen erlaubt. Eingangsgrößen sind der Radius und die Höhe des Zylinders.
\item Schreiben Sie ein Programm, das die Oberfläche eines Rohrs zu
berechnen erlaubt. Eingangsgrößen sind der Innenradius, die
Wandstärke und die Länge des Rohrs.
\end{enumerate}
\begin{minted}[]{scheme}
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; Lösung von Simon Greßmann, I18b ;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;Aufgabe 8a
(define mein-pi 3.14)
;Berechnet Kreisfläche aus Radius
(define Kreisflaeche
  (lambda [radius]
    (* radius radius mein-pi)))
(= (Kreisflaeche 1) 3.14)
(= (Kreisflaeche 2) 12.56)
;Berechnet das Volumen eines Zylinders in Abhängigkeit von Radius und Höhe
(define Zylindervolumen
  (lambda [willi hoehe]
    (* (Kreisflaeche willi) hoehe)))
(= (Zylindervolumen 1 1) 3.14)

;Aufgabe 8b
;Berechnet den Umfang eines Kreises in Anhängigkeit von Pi.
(define Kreisumfang
  (lambda [radius]
    (* 2 mein-pi radius)))
(= (Kreisumfang 1) 6.28)

;Berechnet die Mantelfläche eines Zylinders in Abhängigkeit von Radius 
;und Höhe
(define Mantelflaeche
  (lambda (radius hoehe)
    (* (Kreisumfang radius) hoehe)))
(= (Mantelflaeche 1 1) 6.28)
(= (Mantelflaeche 2 1) 12.56)

;Berechnet die Oberfläche eines Zylinders in Abhängigkeit von Radius und Höhe
(define Zylinderoberflaeche
  (lambda [radius hoehe]
    (+ (* 2 (Kreisflaeche radius)) (Mantelflaeche radius hoehe))))
(= (Zylinderoberflaeche 1 1) 12.56)

;Aufgabe 8c
;Berechnet die Fläche eines Kreisrings in Abhängigkeit von innenradius und 
;Breite
(define Kreisringflaeche
  (lambda [innenradius breite]
    (- (Kreisflaeche (+ innenradius breite)) (Kreisflaeche innenradius))))
(= (Kreisringflaeche 1 1) 9.42)
;Berechnet die Oberfläche eines Rohrs in Abhängigkeit von dessen Inneradius, 
;Wandstärke und Länge.
(define Rohroberflaeche
  (lambda [innenradius wandstaerke laenge]
    (+ (Mantelflaeche (+ innenradius wandstaerke) laenge)
       (Mantelflaeche innenradius laenge)
       (* 2 (Kreisringflaeche innenradius <dstaerke)))))
(= (Rohroberflaeche 1 1 1) 37.68)
\end{minted}

\section{Ersetzungsmodell}
\label{sec:org021ddfd}
Gegeben sei die folgende Funktionsdefinition:
\begin{minted}[]{scheme}
    (define f
       (lambda [x y]
           (+ (* 3 x) (* y y))))
\end{minted}
Werten Sie die folgenden Ausdrücke Schritt für Schritt unter Anwendung
des Ersetzungsmodells aus:
\begin{enumerate}
\item \texttt{(f 1 (* 2 3))}
\begin{minted}[]{scheme}
    (f 1 (* 2 3))
    = ((lambda [x y] (+ (* 3 x) (* y y))) 1 (* 2 3))
    = ((lambda [x y] (+ (* 3 x) (* y y))) 1 6)
    = (+ (* 3 1) (* 6 6))
    = (+ 3 36)
    = 39
\end{minted}
\item \texttt{(+ (f 1 2) (f 2 1))}
\begin{minted}[]{scheme}
    (+ (f 1 2) (f 2 1))
    = (+ ((lambda [x y] (+ (* 3 x) (* y y))) 1 2)
         ((lambda [x y] (+ (* 3 x) (* y y))) 2 1))
    = (+ (+ (* 3 1) (* 2 2)) 
         (+ (* 3 2) (* 1 1)))
    = (+ (+ 3 4) (+ 6 1))
    = (+ 7 7)
    = 14  
\end{minted}

Ausführlich:
\begin{minted}[]{scheme}
    (+ (f 1 2) (f 2 1))
    = (+ ((lambda [x y] (+ (* 3 x) (* y y))) 1 2)
         (f 2 1))
    = (+ ((lambda [x y] (+ (* 3 x) (* y y))) 1 2)
         ((lambda [x y] (+ (* 3 x) (* y y))) 2 1))
    = (+ (+ (* 3 1) (* 2 2))
         (+ ((lambda [x y] (+ (* 3 x) (* y y))) 2 1))
    = (+ (+ (* 3 1) (* 2 2)) 
         (+ (* 3 2) (* 1 1)))
    = (+ (* 3 4) (+ (* 3 2) (* 1 1)))
    = (+ (+ 3 4) (+ 6 1))
    = (+ 7 (+ 6 1))
    = (+ 7 7)
    = 14     
\end{minted}
\item \texttt{(f (f 1 (* 2 3)) 19)}
\begin{minted}[]{scheme}
    (f (f 1 (* 2 3)) 19)
    = ((lambda [x y] (+ (* 3 x) (* y y))) (f 1 (* 2 3)) 19)
    = ((lambda [x y] (+ (* 3 x) (* y y))) 
         ((lambda [x y] (+ (* 3 x) (* y y))) 1 (* 2 3)) 19)
    = ((lambda [x y] (+ (* 3 x) (* y y))) 
         ((lambda [x y] (+ (* 3 x) (* y y))) 1 6) 19)
    = ((lambda [x y] (+ (* 3 x) (* y y))) 
         (+ (* 3 1) (* 6 6)) 19)
    = ((lambda [x y] (+ (* 3 x) (* y y))) (+ 3 36) 19)
    = ((lambda [x y] (+ (* 3 x) (* y y))) 39 19)
    = (+ (* 3 39) (* 19 19))
    = (+ 117 361)
    = 478
\end{minted}
\end{enumerate}

\section{Bedingte Funktion}
\label{sec:org3336344}
Schreiben Sie ein Programm, das aus dem Bruttoeinkommen eines
Arbeitnehmers, das sich aus der Anzahl der Arbeitsstunden und seinem
Bruttostundenlohn ergibt, sein Nettoeinkommen durch Abzug der
Einkommensteuer berechnet. Die Einkommensteuer wird dabei nach einem
steuererklärungaufbierdeckelgeeigneten Tarif ermittelt, der
folgendermaßen definiert ist:

\begin{center}
\begin{tabular}{lr}
\textbf{Einkommen} & \textbf{Steuersatz} [\%]\\
\hline
\(<= 5000\) & 0\\
\(> 5000\; und \leq 10000\) & 15\\
\(>10000\; und \leq 100000\) & 29\\
\(>100000\) & 64\\
\end{tabular}
\end{center}

Der Steuersatz gilt immer nur für die Einkommensanteile in dem
jeweiligen Intervall.

Die Funktion \texttt{nettoeinkommen} soll nach folgendem Schema aufrufbar sein:

\begin{verbatim}
          (nettoeinkommen anzahl-arbeitsStunden stundenLohn)
\end{verbatim}

Hier noch ein paar Testvorgaben:

\begin{minted}[]{scheme}
;; Beispielanwendungen
(= (nettoeinkommen 1 5001) 5000.85)
(= (nettoeinkommen 1 10001) 9250.71)
(= (nettoeinkommen 1 100001) 73150.36)
\end{minted}

Hinweise:

\begin{enumerate}
\item Lesen Sie den Aufgabentext aufmerksam durch. Jeder Satz bedeutet
etwas.

\item Entwickeln Sie die Funktion gemäß den Regel 1 bis 6. Benutzen Sie
Hilfsfunktionen und machen von Variablendefinitionen (benannte
Konstanten, Regel 5) Gebrauch.
\end{enumerate}
\begin{minted}[]{scheme}
;; Steuertabelle gemäß Aufgabenstellung
(define steuergrenzeI 5000)
(define steuergrenzeII 10000)
(define steuergrenzeIII 100000)

(define steuersatz1 0)
(define steuersatz2 15/100)
(define steuersatz3 29/100)
(define steuersatz4 64/100)

;; feste Steuerbeträge gemäß obiger Tabelle 
(define steuern-fuer-steuergrenzeI (* steuersatz1 steuergrenzeI))
(define steuern-fuer-steuergrenzeII
  (+ steuern-fuer-steuergrenzeI
     (* steuersatz2 (- steuergrenzeII steuergrenzeI))))
(define steuern-fuer-steuergrenzeIII
  (+ steuern-fuer-steuergrenzeII
     (* steuersatz3 (- steuergrenzeIII steuergrenzeII))))

;; Ermittlung des Einkommenssteuersatzes aus dem Einkommen gemäß obiger Tabelle
(define steuersatz
  (lambda [einkommen]
    (cond
      [(and (<= einkommen steuergrenzeI) (>= einkommen 0)) steuersatz1]
      [(and (> einkommen steuergrenzeI) (<= einkommen steuergrenzeII)) steuersatz2]
      [(and (> einkommen steuergrenzeII) (<= einkommen steuergrenzeIII)) steuersatz3]
      [(> einkommen steuergrenzeIII) steuersatz4])))
;; Beispielanwendungen
"steuersatz"
(= (steuersatz 2000) 0)
(= (steuersatz steuergrenzeI) 0)
(= (steuersatz 7500) 15/100)
(= (steuersatz steuergrenzeII) 15/100)
(= (steuersatz 50000) 29/100)
(= (steuersatz steuergrenzeIII) 29/100)
(= (steuersatz 1000000) 64/100)

;; Berechnung des Bruttoeinkommens eines Arbeitnehmers
;; der Anzahl der Arbeitsstunden und dem Bruttostundenlohn 
(define bruttoeinkommen
  (lambda [arbeitsstunden stundenlohn]
    (* arbeitsstunden stundenlohn)))
;; Beispielanwendungen
"bruttoeinkommen"
(= (bruttoeinkommen 10 5) 50)

;; Ermittlung der Einkommensteuer aus dem einkommen 
;; gemäß Steuertarif in Aufgabenstellung
(define einkommensteuer
  (lambda [einkommen]
    (cond
      [(= (steuersatz einkommen) steuersatz1)
       (* steuersatz1 einkommen)]
      [(= (steuersatz einkommen) steuersatz2)
       (+ steuern-fuer-steuergrenzeI
          (* steuersatz2 (- einkommen steuergrenzeI)))]
      [(= (steuersatz einkommen) steuersatz3)
       (+ steuern-fuer-steuergrenzeII
          (* steuersatz3 (- einkommen steuergrenzeII)))]
      [(= (steuersatz einkommen) steuersatz4)
       (+ steuern-fuer-steuergrenzeIII
          (* steuersatz4 (- einkommen steuergrenzeIII)))])))
;; Beispielanwendungen
"einkommensteuer"
(= (einkommensteuer 2000) 0)
(= (einkommensteuer steuergrenzeI) 0)
(= (einkommensteuer 8000) 450)
(= (einkommensteuer steuergrenzeII) 750)
(= (einkommensteuer 50000) 12350)
(= (einkommensteuer steuergrenzeIII) 26850)
(= (einkommensteuer 100100) (+ 26850 64))

;; Berechnung des Nettolohns eines Arbeitnehmers aus
;; Anzahl Arbeisstunden und Bruttostundenlohn (in Euro)
(define nettoeinkommen
  (lambda [arbeitsstunden stundenlohn]
    (- (bruttoeinkommen arbeitsstunden stundenlohn)
       (einkommensteuer (bruttoeinkommen arbeitsstunden stundenlohn)))))
;; Beispielanwendungen
"nettoeinkommen"
(= (nettoeinkommen 1 5001) (/ 500085 100))
(= (nettoeinkommen 1 10001) (/ 925071 100))
(= (nettoeinkommen 1 100001) (/ 7315036 100))
\end{minted}

\section{Zusatzaufgaben zu bedingten Funktionen}
\label{sec:org12480f6}

\begin{enumerate}
\item Eine Kreditkartengesellschaft gewährt ihren Kunden nach
Jahresumsatz gestaffelte Rückerstattung von
Kreditkartenbelastungen. Die Rückerstattungen könnten z. B. wie 
folgt aussehen:
\begin{itemize}
\item ein viertel Prozent für die ersten 500€ des Jahresumsatzes (nur
Belastungen keine Gutschriften werden gezählt),
\item ein halbes Prozent für die nächsten 1000€, d. h. für den
Umsatzanteil zwischen 500€ und 1500€,
\item ein dreiviertel Prozent für die nächsten 1000€, d. h. für den
Umsatzanteil zwischen 1500€ und 2500€ und
\item ein Prozent für die Umsatzanteile oberhalb von 2500€.
\end{itemize}
Ein Kunde mit einem Umsatz von 400€ erhält demnach eine Gutschrift
von 1€ (\(= \frac{1}{4} \cdot \frac{1}{100} \cdot 400\)). Ein Kunde
mit einem Umsatz von 1400€ erhält eine Gutschrift von 5,75€:
\begin{itemize}
\item 1,25€ (\(= \frac{1}{4} \cdot \frac{1}{100} \cdot 500\)) für die
ersten 500€ plus
\item 4,50€ (\(=\frac{1}{2} \cdot \frac{1}{100} \cdot 900\)) für die
nächsten 900€
\end{itemize}
Lösen Sie die folgenden Teilaufgaben
\begin{enumerate}
\item Bestimmen Sie manuell die Gutschriften für Umsätze 2000€ und
2600€.
\item Schreiben Sie eine Funktion \texttt{rueckerstattung}, die einen Umsatz
als Argument akzeptiert und den Rückerstattungsbetrag ermittelt.
\end{enumerate}

\begin{minted}[]{scheme}
      ;; berechnet die Rückerstattung für Umsätze zwischen 0 and 500
      (define rueckerstattung-0-500
        (lambda [a]
          (* a (* .25 1/100))))
      ;; Beispielanwendungen
      (= (rueckerstattung-0-500 400) 1)
         
      ;; berechnet die Rückerstattung für Umsätze zwischen 500 and 1500
      (define rueckerstattung-500-1500
        (lambda [a] 
          (+ (rueckerstattung-0-500 500)
             (* (- a 500) (* .50 1/100)))))
      ;; Beispielanwendungen
      (= (rueckerstattung-500-1500 1400) 5.75)
         
      ;; berechnet die Rückerstattung für Umsätze zwischen 1500 and 2500
      (define rueckerstattung-1500-2500
        (lambda [a]
          (+ (rueckerstattung-500-1500 1500)
             (* (- a 1500) (* .75 1/100)))))
      ;; Beispielanwendungen
      (= (rueckerstattung-1500-2500 2000) 10.00)
         
      ;; berechnet die Rückerstattung für Umsätze von 2500 und höher
      (define rueckerstattung-2500+
        (lambda [a]
          (+ (rueckerstattung-1500-2500 2500)
             (* (- a 2500) (* 1 1/100)))))
      ;; Beispielanwendungen
      (= (rueckerstattung-2500+ 2600) 14.75)
         
      ;; berechnet Rückerstattungsbetrag für Kreditkarteninhaber
      ;; bei einem bestimmten Jahresumsatz
      (define rueckerstattung
        (lambda [umsatz]
          (cond
            [(<= umsatz 500)
             (rueckerstattung-0-500 umsatz)]
            [(and (> umsatz 500) (<= umsatz 1500))
             (rueckerstattung-500-1500 umsatz)]
            [(and (> umsatz 1500) (<= umsatz 2500))
             (rueckerstattung-1500-2500 umsatz)]
            [else
             (rueckerstattung-2500+ umsatz)])))
      ;; Beispielanwendungen
      (= (rueckerstattung 400) 1)
      (= (rueckerstattung 1400) 5.75)
      (= (rueckerstattung 2000) 10.00)
      (= (rueckerstattung 2600) 14.75)
\end{minted}
\item Wieviele reelle Lösungen besitzt eine quadratische Gleichung
$$ax^2 + bx + c = 0$$ 
für beliebige Koeffizienten \(a\), \(b\) und \(c\)?
\begin{enumerate}
\item Betrachten Sie zunächst nur \emph{echte} quadratische
Gleichungen, d. h. es gilt \(a\neq0\)
\item Erweitern Sie die Lösung so, dass auch der Fall \(a=0\) korrekt
behandelt wird.
\end{enumerate}

\textbf{Lösung:}
Die Lösungen der quadratischen Gleichung
$$ax^2 + bx + c = 0$$ 
können für den Fall \(a\neq 0\) mit der Formel
$$L_{q}: x_{1,2}=\frac{-b\pm\sqrt{b^2-4ac}}{2a}$$
berechnet werden. Für den Fall \(a=0\) gibt es eine Lösung \(-c/b\),
vorausgesetzt \(b\neq 0\).
\begin{minted}[]{scheme}
   ;; berechnet der Radikanden der Lösungsformel
   (define radikand
     (lambda [a b c]
       (- (sqr b) (* 4 a c))))
   ;: Beispielanwendungen
   (= (radikand 1 2 1) 0)
   (= (radikand 1 1 1) -3)
   (= (radikand 1 3 1) 5)
   
   ;; berechnet die Anzahl der Lösungen einer quadratischen Gleichung mit
   ;; den Koeffizienten a, b und c
   (define anzahl-loesungen
     (lambda [a b c]
       (cond
         [(= 0 a) (cond
                    [(= 0 b c) "unendlich viele Lösungen"]
                    [(and (= 0 b) (not (= 0 c))) "keine Lösung"]
                    [else "eine Lösung"])]
         [else (cond [(> (radikand a b c) 0) "zwei Lösungen"]
                     [(= (radikand a b c) 0) "eine Lösung"]
                     [else "keine Lösung"])])))
   ;; Beispielanwendugen
   (string=? (anzahl-loesungen 0 0 0) "unendlich viele Lösungen")
   (string=? (anzahl-loesungen 0 0 1) "keine Lösung")
   (string=? (anzahl-loesungen 0 1 2) "eine Lösung")
   (string=? (anzahl-loesungen 1 4 1) "zwei Lösungen")
   (string=? (anzahl-loesungen 1 2 1) "eine Lösung")
   (string=? (anzahl-loesungen 4 1 1) "keine Lösung")
   
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;;; Funktion zur Berechnung der Lösungen einer quadratischen Gleichung;;;
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   
   ;; Eine quadgl-loesung ist ein Wert
   ;;  (make-quadgl-loesung art x1 x2)
   ;; wobei art die Anzahl der Lösungen durch eine Zeichenkette
   ;; ("trivial" "keine" "eine" "zwei") repräsentiert wird und
   ;; x1, x2 ggf. die Lösungen enthalten
   (define-struct quadgl-loesung [art x1 x2])
   
   ;; berechnet die Lösungen einer quadratischen Gleichung mit
   ;; den Koeffizienten a, b und c
   (define loesungen
     (lambda [a b c]
       (cond
         [(= 0 a) (cond
                    [(= 0 b c) 
                       (make-quadgl-loesung "trivial" 0 0)]
                    [(and (= 0 b) (not (= 0 c))) 
                       (make-quadgl-loesung "keine" 0 0)]
                    [else (make-quadgl-loesung "eine" (/ (- c) b) 0)])]
         [else (cond [(> (radikand a b c) 0)
                      (make-quadgl-loesung 
                          "zwei"
                          (/ (+ (- b) (sqrt (radikand a b c)))
                             (* 2 a))
                          (/ (- (- b) (sqrt (radikand a b c)))
                             (* 2 a)))] 
                     [(= (radikand a b c) 0)
                      (make-quadgl-loesung "eine" (/ (- b) (* 2 a)) 0)]
                     [else (make-quadgl-loesung "keine" 0 0)])])))
   ;; Beispielanwendugen
   (string=? (quadgl-loesung-art (loesungen 0 0 0)) "trivial")
   (string=? (quadgl-loesung-art (loesungen 0 0 1)) "keine")
   (and (string=? (quadgl-loesung-art (loesungen 0 1 2)) "eine")
        (= (quadgl-loesung-x1 (loesungen 0 1 2)) -2))
   (and (string=? (quadgl-loesung-art (loesungen 1 4 3)) "zwei")
        (= (quadgl-loesung-x1 (loesungen 1 4 3)) -1)
        (= (quadgl-loesung-x2 (loesungen 1 4 3)) -3))
   (and (string=? (quadgl-loesung-art (loesungen 1 2 1)) "eine")
        (= (quadgl-loesung-x1 (loesungen 1 2 1)) -1))
   (string=? (quadgl-loesung-art (loesungen 4 1 1)) "keine")
\end{minted}
\end{enumerate}
\section{Datenabstraktion}
\label{sec:org2a7452f}
Befolgen Sie für die Lösung der Aufgabe die Regeln 7 und 8!

\begin{enumerate}
\item Definieren Sie eine Datenstruktur für „Zeitpunkte seit
Mitternacht”, die aus den Komponenten \texttt{stunden}, \texttt{minuten} und
\texttt{sekunden} besteht.

Entwickeln Sie eine Funktion \texttt{zeit->sekunden}, die eine
   Zeitpunkt-seit-Mittnacht-Struktur verarbeitet und die seit
   Mitternacht vergangenen Sekunden berechnet.

\item Definieren Sie geeignete \textbf{Datenstrukturen} für Kreise, die durch
\begin{itemize}
\item die Koordinaten des Mittelpunkts und
\item den Radius
\end{itemize}

gegeben sind.

Schreiben Sie eine Funktion, die prüft, ob ein Punkt
   innerhalb eines Kreises liegt.
\begin{minted}[]{scheme}
; Autor der Lösungen zu Aufgabe 12: David Lüder (I16b)
; Aufgabe 12a

; Eine Tageszeit ist ein Wert
; (make-daytime h m s)
; wobei h die Stunden, m die Minuten und s die Sekunden angeben, 
; um die Uhrzeit zu definieren.
(define-struct daytime [h m s])

; gibt die absolute Zahl der vergangenen Sekunden seit Mitternacht 
; bei gegebeher Tageszeit zurück.
(check-expect (zeit->sekunden (make-daytime 0 0 0)) 0)
(check-expect (zeit->sekunden (make-daytime 0 2 36)) 156)
(check-expect (zeit->sekunden (make-daytime 2 1 50)) 7310)
(check-expect (zeit->sekunden (make-daytime 23 59 59)) 86399)
(define zeit->sekunden
  (lambda [uhrzeit]
    (+ (* (daytime-h uhrzeit) 3600)
       (* (daytime-m uhrzeit) 60)
       (daytime-s uhrzeit))))

; Aufgabe 12b

; Ein Punkt ist ein Wert
; (make-point x y)
; wobei x und y Zahlen sind, welche die Position im Zweidimensionalen 
; angeben.
(define-struct point [x y])

; Ein Kreis ist ein Wert
; (make-circle center radius)
; wobei center ein Punkt ist, welcher den Mittelpunkt darstellt und radius
; eine Zahl ist, welche den Radius des Kreises angibt.
(define-struct circle [center radius])

; berechnet den Abstand zwischen zwei übergebenen Punkten im Zweidimensionalen
(check-expect (point-distance (make-point 1 1) (make-point 1 2)) 1)
(check-expect (point-distance (make-point 7 2) (make-point 2 2)) 5)
(check-within (point-distance (make-point 5 5) (make-point 2 4)) 3.16 3.17)
(define point-distance
  (lambda [p1 p2]
    (sqrt (+ (sqr (- (point-x p1) (point-x p2)))
             (sqr (- (point-y p1) (point-y p2)))))))

; prüft, ob ein Punkt innerhalb eines Kreises liegt, dabei werden der Kreis 
; und der Punkt übergeben
(check-expect (in-circle? (make-circle (make-point 10 10) 2)
                          (make-point 10 9)) #true)
(check-expect (in-circle? (make-circle (make-point 7 3) 5)
                          (make-point 2 2)) #false)
(check-expect (in-circle? (make-circle (make-point 9 2) 7)
                          (make-point 8 4)) #true)
(define in-circle?
  (lambda [circle point]
    (<= (point-distance (circle-center circle) point) (circle-radius circle))))
\end{minted}
\item Definieren Sie eine Datenstruktur für Gäste einer Veranstaltung.
Ein Gast besteht aus einer Zeichenkette für den Namen, einem
boolschen Wert, der angibt ob es sich um eine Frau handelt, und einem
boolschen Wert, der angibt ob es sich um einen Vegetarier handelt.

Schreiben Sie eine Funktion, die prüft, ob ein Gast ein nicht
weiblicher Vegetarier ist.
\begin{minted}[]{scheme}
; Ein Gast besteht aus
; - einer Zeichenkette für den Namen
; - einem boolschen Wert, der angibt ob es sich um eine Frau handelt
; - einem boolschen Wert, der angibt ob es sich um einen Vegetarier handelt

(define-struct gast [name weiblich? vegetarier?])

;; prüft, ob ein Gast ein nicht weiblicher Vegetarier ist
(define nicht-weiblicher-vegetarier?
  (lambda [gast]
    (and (not (gast-weiblich? gast)) (gast-vegetarier? gast))))

;; Beispielanwendungen
(nicht-weiblicher-vegetarier? (make-gast "Karl" #false #true))
(not (nicht-weiblicher-vegetarier? (make-gast "Klara" #true #true)))
(not (nicht-weiblicher-vegetarier? (make-gast "Karl" #false #false)))

\end{minted}
\end{enumerate}

\section{Datenabstraktion -- Zusatzaufgabe}
\label{sec:org3723200}
\subsection{Vorbemerkungen}
\label{sec:org2913aaf}
In den Lehrsprachen von DrRacket gibt es ein vordefinierte
Strukturdefinition namens \texttt{posn} für Punkte in der Ebene, die genauso
aufgebaut ist wie die Strukturdefinition \texttt{point} aus der
Vorlesung. Die damit vordefinierten Funktionen sind
\begin{itemize}
\item die Konstruktionsfunktion \texttt{make-posn},
\item die Selektionsfunktionen \texttt{posn-x} und \texttt{posn-y} und
\item das Typprädikat \texttt{posn?}.
\end{itemize}

Wenn man über den Menüpunkt \texttt{Sprache->Teachpack hinzufügen...} das
Teachpack \texttt{draw.rkt} auswählt und anschließend den \texttt{Start}-Knopf
drückt, steht ein Grafikpaket mit den folgenden Funktionen bereit:
\begin{description}
\item[{\texttt{draw-solid-line}}] erwartet zwei Punkte (\texttt{posn}-Strukturen), die
den Anfang und das Ende einer Strecke definieren sowie eine Farbe
als Argumente
\item[{\texttt{draw-solid-rect}}] erwartet vier Argumente: ein Punkt für die
linke obere Ecke des Rechtecks, zwei Zahlen für Breite und Höhe
des Rechecks und eine Farbe
\item[{\texttt{draw-solid-disk}}] erwartet drei Argumente: ein Punkt für den
Mittelpunkt, eine Zahl für den Radius der Scheibe und eine Farbe
\item[{\texttt{draw-circle}}] erwartet drei Argumente: ein Punkt für den
Mittelpunkt, eine Zahl für den Radius des Kreises und eine Farbe
\end{description}
Alle Funktionen liefern als Funktionswert \texttt{true}, wobei wir in diesem Fall
an den Funktionswerten weniger interessiert sind als an ihrem
\textbf{Effekt}. Der besteht nämlich darin, dass die Prozeduren jeweils eine
Strecke, ein Rechteck, eine Scheibe und einen Kreis auf eine zuvor
definierte Zeichenfläche zeichnen.

Eine Zeichenfläche kann mit einem Ausdruck \texttt{(start x y)} erzeugt
werden, wobei \texttt{x} und \texttt{y} die Breite und die Höhe in Pixeln der
Zeichenfläche angeben. Zum Beispiel erzeugt ein Aufruf \texttt{(start 150
200)} die folgende Zeichenfläche: \begin{center}
\includegraphics[width=.9\linewidth]{./Abbildungen/canvas.png}
\end{center} Ein
Anwendungsbeispiel zeigt die folgende Abbildung:
\begin{center}
\includegraphics[width=.9\linewidth]{./Abbildungen/drawings.png}
\end{center}

Der \textbf{Ursprung des Koordinatensystems} liegt in der linken oberen Ecke
der Zeichenfläche. Die x-Koordinate zählt nach rechts, die
y-Koordinate nach unten positiv: \\
\url{http://www.htdp.org/2003-09-26/Book/curriculum1aa-Z-G-17.gif}

Die \textbf{Farben} werden durch Symbole wie '\texttt{yellow}, '\texttt{red}, '\texttt{green}
angegeben. Bitte beachten Sie das vorangestellte Hochkomma.

Für jede Zeichenoperation gibt es eine korrespondierende
\textbf{Löschoperation}: \texttt{clear-solid-line}, \texttt{clear-solid-rect},
\texttt{clear-solid-disk} und \texttt{clear-circle}. Wenn diese Funktionen mit den
gleichen Argumenten wie zuvor die zugehörigen \texttt{draw}-Operationen aufgerufen
werden, werden die entsprechenden Figuren von der Zeichenfläche
entfernt.

Um \textbf{mehrere Zeichenoperationen hintereinander} ausführen zu
können, d. h. \textbf{mehrere Effekte} zu \textbf{kombininieren}, macht man davon
Gebrauch, dass die einzelnen Zeichenoperationen \texttt{\#true} als Resultat
liefern. Dadurch ist es möglich mehrere Zeichenoperationen
hintereinander auszuführen, indem man sie in eine Und-Verknüpfung
einschließt:
\begin{verbatim}
(and exp1 exp2)
\end{verbatim}

Dieser Ausdruck bewirkt, dass man zuerst den Effekt von \texttt{exp1} und
anschließend den von \texttt{exp2} zu sehen bekommt.

Mit \texttt{(stop)} wird die Zeichenfläche geschlossen.

\subsection{Aufgabenstellungen}
\label{sec:orgcc3ed1a}
\begin{enumerate}
\item Experimentieren Sie mit den o. g. Funktionen.
\item Kreise und Rechtecke bewegen
\begin{enumerate}
\item Entwickeln Sie eine Datenstruktur \texttt{circle} für farbige Kreise. Diese
sollen durch drei Komponenten definiert sein: den Mittelpunkt,
den Radius und die Farbe des Umfangs.
\item Schreiben Sie die Datendefinition für Kreise und die
Funktionsschablone (gemäß Regeln 7 und 8) für Kreise
verarbeitende Funktionen.
\item Benutzen Sie die Schablone für die Entwicklung einer Funktion
\texttt{draw-a-circle}. Die Funktion erwartet einen Kreis (\texttt{circle}) als
Argument und zeichnet ihn auf einer Zeichenfläche. Der
Funktionswert sollte \texttt{\#true} sein.
\item Entwickeln Sie eine Funktion \texttt{translate-circle} mit einer
\texttt{circle}-Struktur \texttt{c} und einer \texttt{posn}-Struktur \texttt{delta} als
Parameter. Die Funktion liefert einen \texttt{circle} als Resultat,
dessen Mittelpunkt gegenüber dem von \texttt{c} um den x-Wert von
\texttt{delta} nach rechts und um den y-Wert von \texttt{delta} nach unten
verschoben ist. Die Funktion hat keinen Effekt auf der
Zeichenfläche.
\item Schreiben Sie eine Funktion \texttt{clear-a-circle}, die einen Kreis
von der Zeichenfläche entfernt.
\item Schreiben Sie eine Funktion \texttt{draw-and-clear-circle}, die eine
\texttt{circle}-Struktur zeichnet, eine kurze Zeit wartet und sie
anschließend wieder entfernt. Für die Implementierung der
Wartezeit steht die Prozedur \texttt{sleep-for-a-while} zur
Verfügung. Der Aufruf \\
\texttt{(sleep-for-a-while 3)} erzeugt eine
Wartezeit von drei Sekunden. Der Funktionswert ist \texttt{\#true}.

Die Funktion
\begin{minted}[]{scheme}
;; zeichnet und löscht einen Kreis a-circle und 
;; bewegt ihn um a-posn
(define move-circle
   (lambda [a-posn a-circle]
      (cond
        [(draw-and-clear-circle a-circle) 
           (translate-circle a-circle a-posn)]
        [else a-circle])))
\end{minted}
zeichnet und löscht einen Kreis auf der Zeichenfläche und
erzeugt anschließend einen (verschobenen) Kreis, so dass eine
erneute Zeichenoperation den Kreis an einer neuen Position
erscheinen lässt. 

Zum Beispiel bewegt der Ausdruck
\begin{minted}[]{scheme}
(draw-a-circle 
 (move-circle 
  (make-posn 10 0) 
  (move-circle
   (make-posn 10 0) 
    (move-circle 
     (make-posn 10 0)
     (make-circle (make-posn 10 50) 10 'green)))))
\end{minted}
einen grünen Kreis dreimal um 10 Pixel nach rechts. Der äußere
Aufruf von \texttt{draw-a-circle} sorgt dafür, dass auch die letzte
Position des Kreises angezeigt wird.

Das sei nur ein kleine Anregung für eigene „Animationen“.
\end{enumerate}
\end{enumerate}
\begin{minted}[]{scheme}
;; A circle is a structure:
;;   (make-circle P R C)
;; where P is a posn describing the center of the circle,
;;       R is a number describing the radius of the circle,
;;   and C is a color.
(define-struct circle [center radius color])

#|
;; Funktionsschablone für circle-verarbeitende Funktionen

(define fun-for-circles 
  (lambda [a-circle]
    ... (circle-center a-circle) ...
    ... (circle-radius a-circle) ...
    ... (circle-color a-circle) ...)(
    |#

;; draws the disk on the screen
;; no tests, because function always returns true
(define draw-a-circle
  (lambda [c]
    (draw-circle (circle-center c)
                 (circle-radius c)
                 (circle-color c))))

;; EXAMPLES 

(start 300 300)
(draw-a-circle (make-circle (make-posn 50 50) 50 'red))

;; determines if p is inside the circle c.
(check-expect (in-circle? (make-circle (make-posn 6 5) 1 'blue) 
                          (make-posn 6 5)) #true)
(check-expect (in-circle? (make-circle (make-posn 6 5) 1 'green) 
                          (make-posn 5.5 5)) #true)
(check-expect (in-circle? (make-circle (make-posn 6 5) 1 'yellow) 
                          (make-posn 1 5)) #false)
(define in-circle?
  (lambda [c p]
    (<= (sqrt (+ (sqr (- (posn-x (circle-center c))
                         (posn-x p)))
                 (sqr (- (posn-y (circle-center c))
                         (posn-y p)))))
        (circle-radius c))))

;; to translate a-circle by delta (posn) 
(check-expect  (translate-circle
                (make-circle (make-posn 0 0) 5 'blue)
                (make-posn 10 5))
               (make-circle (make-posn 10 5) 5 'blue))
(define translate-circle 
  (lambda [a-circle delta]
    (make-circle (make-posn
                  (+ (posn-x delta) (posn-x (circle-center a-circle)))
                  (+ (posn-y delta) (posn-y (circle-center a-circle))))
                 (circle-radius a-circle)
                 (circle-color a-circle))))

;; to clear a-circle
;; no tests, because function always returns true
(define clear-a-circle
  (lambda [a-circle]
    (clear-circle
     (circle-center a-circle)
     (circle-radius a-circle))))

;; EXAMPLES
(start 100 100)
(draw-a-circle (make-circle (make-posn 50 50) 25 'red))
(clear-a-circle (make-circle (make-posn 50 50) 25 'red))

;; draw-and-clear : circle -> true
;; to draw a circle, wait 1/2 second, and clear it
(define draw-and-clear-circle
  (lambda [a-circle]
    (and (draw-a-circle a-circle)
         (sleep-for-a-while 1/2)
         (clear-a-circle a-circle))))

;; EXAMPLES
(start 100 100)
(draw-and-clear-circle (make-circle (make-posn 50 50) 50 'blue))

;; zeichnet und löscht einen Kreis a-circle und bewegt ihn um a-posn
;; no tests, because function always returns true
(define move-circle
  (lambda [a-posn a-circle]
    (cond
      [(draw-and-clear-circle a-circle) (translate-circle a-circle a-posn)]
      [else a-circle])))

(start 60 100)
(draw-a-circle 
 (move-circle 
  (make-posn 10 0) 
  (move-circle
   (make-posn 10 0) 
   (move-circle 
    (make-posn 10 0)
    (make-circle (make-posn 10 50) 10 'green)))))
\end{minted}
\section{Datenabstraktion -- gemischte Daten}
\label{sec:orge4cc807}
Lösen Sie die Aufgabe unter Anwendung der passenden Regeln!

Ein \emph{Mitarbeiter} ist entweder

\begin{itemize}
\item ein \emph{Festangestellter} oder
\item ein \emph{Werkstudent}
\end{itemize}

Ein \emph{Festangestellter} wird definiert durch

\begin{itemize}
\item seinen Namen,
\item sein Grundgehalt,
\item die im letzten Monat geleisteten Arbeitsstunden.
\end{itemize}

Ein \emph{Werkstudent} wird definiert durch

\begin{itemize}
\item seinen Namen,
\item seinen Stundenlohn,
\item die im letzten Monat geleisteten Arbeitsstunden.
\end{itemize}

Definieren Sie 

\begin{itemize}
\item geeignete Datenstrukturen für \emph{Mitarbeiter},
\item eine Funktionsschablone für Funktionen, die \emph{Mitarbeiter}
verarbeiten.
\end{itemize}

Entwickeln auf der Grundlage dieser Schablone eine Funktion, die den
Bruttomonatslohn eines Mitarbeiters berechnet. Bei \emph{Festangestellten}
berechnet sich der Monatslohn aus dem Grundgehalt zuzüglich
Überstundenentgelt. Überstunden sind die über die monatliche
Sollarbeitszeit (die als globale Konstante definiert wird)
hinausgehenden Arbeitsstunden. Der Stundenlohn pro Überstunde berechnet
sich aus dem Grundgehalt und der monatlichen Sollarbeitszeit plus
\(25\%\). Minderstunden bleiben unberücksichtigt.
\begin{minted}[]{scheme}
; Autor der Lösung zu Aufgabe 14: Marlon Tobaben (I16b)

;;Die Konstante für die monatliche sollarbeitszeit eines angestellten
(define sollarbeitszeit 120)

;; Ein mitarbeiter ist entweder
;; - ein festangestellter
;; - ein werksstudent
;; name: mitarbeiter

;; Ein festangestellter ist ein Wert 
;;   (make-festangestellter name grundgehalt arbeitsstunden)
;;  wobei der name ein string und
;;       das grundgehalt und arbeitsstunden Zahlen sind.
(define-struct festangestellter [name grundgehalt arbeitsstunden])

;; Ein werksstudent ist ein Wert 
;;   (make-werksstudent name stundenlohn arbeitsstunden)
;;  wobei der name ein string und
;;       das stundenlohn  und arbeitsstunden Zahlen sind.
(define-struct werksstudent [name stundenlohn arbeitsstunden])

;; Die Funktion ueberstunden-festangestellter berechnet die Überstunden eines
;; festangestellten anhand der sollarbeitszeit
(check-expect (ueberstunden-festangestellter 120)  0)
(check-expect (ueberstunden-festangestellter 130) 10)
(check-expect (ueberstunden-festangestellter 150) 30)

(define ueberstunden-festangestellter
  (lambda [arbeitsstunden]
    (cond [(> (- arbeitsstunden sollarbeitszeit) 0)
           (- arbeitsstunden sollarbeitszeit)]
          [else 0])))

;; Funktion bruttolohn-festangesteller berechnet den Bruttolohn eines Festanstellten 
;;unter Berücksichtung der sollarbeitszeit und mit 25% zuschlag bei ueberstunden
(check-expect (bruttolohn-festangestellter
               (make-festangestellter "Peter" 3000 120))  3000)
(check-expect (bruttolohn-festangestellter
               (make-festangestellter "Heinz" 3000   0))  3000)
(check-expect (bruttolohn-festangestellter
               (make-festangestellter "Heinz" 3000 240))  6750)
(define bruttolohn-festangestellter
  (lambda [f]
    (+ (festangestellter-grundgehalt f) 
       (* (ueberstunden-festangestellter (festangestellter-arbeitsstunden f))
          (* (/ (festangestellter-grundgehalt f) sollarbeitszeit) 1.25)))))

;; Funktion bruttolohn-werkstundent berechnet den Bruttolohn eines werksstundenten
(check-expect (bruttolohn-werksstudent (make-werksstudent "Peter" 10 120))  1200)
(check-expect (bruttolohn-werksstudent (make-werksstudent "Heinz"  0  20))     0)
(check-expect (bruttolohn-werksstudent (make-werksstudent "Heinz" 20 120))  2400)
(define bruttolohn-werksstudent
  (lambda [w]
    (* (werksstudent-stundenlohn w) (werksstudent-arbeitsstunden w))))

;;Funktion bruttolohn-mitarbeiter berechnet den bruttolohn eines mitarbeiters
(check-expect (bruttolohn-mitarbeiter (make-werksstudent "Heinz"  0  20)) 0)
(check-expect (bruttolohn-mitarbeiter (make-festangestellter "Heinz" 3000  0)) 3000)
(define bruttolohn-mitarbeiter
  (lambda [mitarbeiter]
    (cond 
      [(festangestellter? mitarbeiter) (bruttolohn-festangestellter mitarbeiter)]
      [(werksstudent?     mitarbeiter) (bruttolohn-werksstudent     mitarbeiter)])))
\end{minted}

\section{Datenabstraktion -- gemischte Daten -- Zusatzaufgabe}
\label{sec:org53e0380}
\subsection{Vorbemerkung}
\label{sec:org5a9a920}
Diese Aufgabe stellt eine Fortführung von Aufgabe 13 dar. Falls Sie
diese noch nicht bearbeitet haben, sollten Sie zunächst damit beginnen.
\subsection{Aufgabenstellungen}
\label{sec:orgadfac21}
\begin{enumerate}
\item Enwtickeln Sie eine Datenstrukturdefinition für farbige
Rechtecke. Ein Rechteck sei durch einen Punkt (\texttt{posn}-Struktur),
der die linke obere Ecke des Rechtecks bildet, zwei Zahlen für die
Höhe und die Breite des Rechecks und ein Symbol für seine Farbe
charakterisiert.
\item Entwickeln sie die folgenden Funktionen
\begin{description}
\item[{\texttt{draw-a-rectangle}}] zeichnet das Rechteck auf die Zeichenfläche. Im
Gegensatz zu den Kreisen aus Aufgabe 13 sollen die Rechtecke immer
mit der Farbe gefüllt gezeichnet werden.
\item[{\texttt{in-rectangle?}}] akzeptiert ein Rechteck und einen Punkt als
Argumente und prüft, ob der Punkt innerhalb des Rechecks liegt.
\item[{\texttt{translate-rectangle}}] verschiebt ein Rechteck auf die gleiche
Art, wie es die Funktion \texttt{translate-circle} aus Aufgabe 13 mit
Kreisen tut. Diese Funktion hat keinen Effekt auf der
Zeichenfläche.
\item[{\texttt{clear-a-rectangle}}] entfernt ein Rechteck von der Zeichenfläche.
\item[{\texttt{move-rectangle}}] soll analog zur Funktion \texttt{move-circle} aus
Aufgabe 13 ein Rechteck zeichnen, löschen und mit einem
verschobenen Rechteck antworten.
\end{description}
\item Definieren Sie eine gemischte Datenstruktur für Figuren (shapes),
die als Generalisierung mindestens Kreise und Rechtecke umfassen
sollte. Schreiben Sie die Funktionsschablone für Funktionen, die
Figuren verarbeiten, auf.
\item Programmieren Sie nun die oben genannten Funktionen für Figuren
(z. B. \texttt{draw-a-shape})
\end{enumerate}
\begin{minted}[]{scheme}
;; a shape is either:
;;   - a circle
;;   - a rectangle

;; A circle is a structure:
;;   (make-circle P R C)
;; where P is a posn describing the center of the circle,
;;       R is a number describing the radius of the circle,
;;   and C is a color.
(define-struct circle (center radius color))

;; draws the disk on the screen
;; no tests, because function always returns true
(define draw-a-circle
  (lambda [c]
    (draw-circle (circle-center c)
                 (circle-radius c)
                 (circle-color c))))

;; determines if p is inside the circle c.
(check-expect (in-circle? (make-circle (make-posn 6 5) 1 'blue) 
                          (make-posn 6 5)) #true)
(check-expect (in-circle? (make-circle (make-posn 6 5) 1 'green) 
                          (make-posn 5.5 5)) #true)
(check-expect (in-circle? (make-circle (make-posn 6 5) 1 'yellow) 
                          (make-posn 1 5)) #false)
(define in-circle?
  (lambda [c p]
    (<= (sqrt (+ (sqr (- (posn-x (circle-center c))
                         (posn-x p)))
                 (sqr (- (posn-y (circle-center c))
                         (posn-y p)))))
        (circle-radius c))))

;; to translate a-circle by delta (posn) 
(check-expect  (translate-circle
                (make-circle (make-posn 0 0) 5 'blue)
                (make-posn 10 5))
               (make-circle (make-posn 10 5) 5 'blue))
(define translate-circle 
  (lambda [a-circle delta]
    (make-circle (make-posn
                  (+ (posn-x delta) (posn-x (circle-center a-circle)))
                  (+ (posn-y delta) (posn-y (circle-center a-circle))))
                 (circle-radius a-circle)
                 (circle-color a-circle))))

;; to clear a-circle
;; no tests, because function always returns true
(define clear-a-circle
  (lambda [a-circle]
    (clear-circle
     (circle-center a-circle)
     (circle-radius a-circle))))

;; draw-and-clear : circle -> true
;; to draw a circle, wait 1/2 second, and clear it
(define draw-and-clear-circle
  (lambda [a-circle]
    (and (draw-a-circle a-circle)
         (sleep-for-a-while 1/2)
         (clear-a-circle a-circle))))

;; to draw, to clear, and to move a-circle by a-posn
;; no tests, because function always returns true
(define move-circle
  (lambda [a-posn a-circle]
    (cond
      [(draw-and-clear-circle a-circle) (translate-circle a-circle a-posn)]
      [else a-circle])))

;; A rectangle is a structure:
;;   (make-rectangle P W H)
;; where P is a posn, W is a number and H is a number.
(define-struct rectangle (nw-corner width height color))

;; DATA EXAMPLES
(define example-rectangle1 (make-rectangle (make-posn 20 20) 260 260 'red))
(define example-rectangle2 (make-rectangle (make-posn 60 60) 180 180 'blue))

;; to draw a-rect
;; no tests, because function always returns true
(define draw-a-rectangle
  (lambda [a-rectangle]
    (draw-solid-rect
     (rectangle-nw-corner a-rectangle)
     (rectangle-width a-rectangle)
     (rectangle-height a-rectangle)
     (rectangle-color a-rectangle))))

;; to determine if a-posn is in a-rectangle, or not
(check-expect (in-rectangle? example-rectangle1 (make-posn 0 0)) #false)
(check-expect (in-rectangle? example-rectangle1 (make-posn 25 0)) #false)
(check-expect (in-rectangle? example-rectangle1 (make-posn 0 25)) #false)
(check-expect (in-rectangle? example-rectangle1 (make-posn 25 25)) #true)
(define in-rectangle?
  (lambda [a-rectangle a-posn]
    (and (<= (posn-x (rectangle-nw-corner a-rectangle))
             (posn-x a-posn)
             (+ (posn-x (rectangle-nw-corner a-rectangle))
                (rectangle-width a-rectangle)))
         (<= (posn-y (rectangle-nw-corner a-rectangle))
             (posn-y a-posn)
             (+ (posn-y (rectangle-nw-corner a-rectangle))
                (rectangle-height a-rectangle))))))

;; to translate a-rectangle by delta (posn) 
(check-expect (translate-rectangle example-rectangle1 (make-posn 30 0))
              (make-rectangle (make-posn 50 20) 260 260 'red))
(define translate-rectangle
  (lambda [a-rectangle delta]
    (make-rectangle (make-posn
                     (+ (posn-x delta) (posn-x (rectangle-nw-corner a-rectangle)))
                     (+ (posn-y delta) (posn-y (rectangle-nw-corner a-rectangle))))
                    (rectangle-width a-rectangle)
                    (rectangle-height a-rectangle)
                    (rectangle-color a-rectangle))))

;; to erase a rectangle
;; no tests, because function always returns true
(define clear-a-rectangle
  (lambda [a-rectangle]
    (clear-solid-rect 
     (rectangle-nw-corner a-rectangle)
     (rectangle-width a-rectangle)
     (rectangle-height a-rectangle))))

;; to draw a circle, wait 1/2 second, and clear it
;; no tests, because function always returns true
(define draw-and-clear-rectangle
  (lambda [a-rectangle]
    (and (draw-a-rectangle a-rectangle)
         (sleep-for-a-while 1/2)
         (clear-a-rectangle a-rectangle))))

;; to draw and clear a rectangle, translate it by delta pixels
;; no tests, because function always returns true
(define move-rectangle
  (lambda [delta a-rectangle]
    (cond
      [(draw-and-clear-rectangle a-rectangle) 
       (translate-rectangle a-rectangle delta)] 
      [else a-rectangle])))

;;;;;;;;

;; draws a-shape
(define draw-shape
  (lambda [a-shape]
    (cond
      [(circle? a-shape) 
       (draw-a-circle a-shape)]
      [(rectangle? a-shape)
       (draw-a-rectangle a-shape)])))
;; EXAMPLES AS TESTS
(start 200 200)
(draw-shape (make-circle (make-posn 30 30) 20 'red)) 
(draw-shape (make-rectangle  (make-posn 30 60) 20 50 'blue))

; -------------------------------------------------------------------------

;; translates a-shape by delta (posn)
(check-expect (translate-shape 
                  (make-circle (make-posn 30 30) 20 'red) (make-posn 10 0))  
              (make-circle (make-posn 40 30) 20 'red))
(check-expect (translate-shape (make-rectangle (make-posn 30 60) 20 50 'blue) 
                               (make-posn 20 0))
              (make-rectangle  (make-posn 50 60) 20 50 'blue))
(define translate-shape
  (lambda [a-shape delta]
    (cond
      [(circle? a-shape) 
       (translate-circle a-shape delta)]
      [(rectangle? a-shape)
       (translate-rectangle a-shape delta)])))

;; erases a-shape
;; no tests, because function always returns true
(define clear-shape
  (lambda [a-shape]
    (cond
      [(circle? a-shape) 
       (draw-a-circle a-shape)]
      [(rectangle? a-shape)
       (draw-a-rectangle a-shape)])))

;; EXAMPLES 
(start 200 200)
(draw-shape (make-circle (make-posn 30 30) 20 'red))
(draw-shape (make-rectangle  (make-posn 30 60) 20 50 'blue))
(clear-shape (make-circle (make-posn 30 30) 20 'red)) 
(clear-shape (make-rectangle (make-posn 30 60) 20 50 'blue))

; -------------------------------------------------------------------------

;; draws a-shape, waits one second, clears a-shape,
;; returns a-shape translated by delta pixels.
(define move-shape
  (lambda [a-shape delta]
    (cond
      [(and (draw-shape a-shape)
            (sleep-for-a-while 1)
            (clear-shape a-shape))
       (translate-shape a-shape delta)]
      [else 
       (translate-shape a-shape delta)])))

;; EXAMPLES AS TESTS

(define my-shape (make-circle  (make-posn 30 30) 20 'red))
(start 100 100)
(move-shape
 (move-shape
  (move-shape
   (move-shape my-shape (make-posn 10 0))
   (make-posn 10 0))
  (make-posn 10 0))
 (make-posn 10 0))
"should be"
(make-circle (make-posn 70 30) 20 'red)
\end{minted}

\section{Listenkonstruktion und -zerlegung}
\label{sec:orgc0f0a0d}
Werten Sie die folgenden Funktionsaufrufe aus:

\begin{center}
\begin{tabular}{lll}
Nr. & Ausdruck & Lösung\\
\hline
a) & \texttt{(first '((A) B C D))} & \\
b) & \texttt{(rest '((A)(B C D)))} & \\
c) & \texttt{(cons '(A B) '(A B))} & \\
d) & \texttt{(cons 'A '())} & \\
e) & \texttt{(first '(((A))))} & \\
f) & \texttt{(rest '(((A))))} & \\
g) & \texttt{(cons '((A)) empty)} & \\
h) & \texttt{(equal? 'X1 'X2)} & \\
i) & \texttt{(equal? '(X1) 'X2)} & \\
j) & \texttt{(equal? '(X1) '(X2))} & \\
k) & \texttt{(list? 'X1)} & \\
l) & \texttt{(list? '(X1))} & \\
m) & \texttt{(empty? '())} & \\
n) & \texttt{(empty? '(()))} & \\
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{lll}
Nr. & Ausdruck & Lösung\\
\hline
a) & \texttt{(first '((A) B C D))} & (A)\\
b) & \texttt{(rest '((A)(B C D)))} & ((B C D))\\
c) & \texttt{(cons '(A B) '(A B))} & ((A B) A B)\\
d) & \texttt{(cons 'A '())} & (A)\\
e) & \texttt{(first '(((A))))} & ((A))\\
f) & \texttt{(rest '(((A))))} & ()\\
g) & \texttt{(cons '((A)) empty)} & (((A)))\\
h) & \texttt{(equal? 'X1 'X2)} & \#false\\
i) & \texttt{(equal? '(X1) 'X2)} & \#false\\
j) & \texttt{(equal? '(X1) '(X2))} & \#false\\
k) & \texttt{(list? 'X1)} & \#false\\
l) & \texttt{(list? '(X1))} & \#true\\
m) & \texttt{(empty? '())} & \#true\\
n) & \texttt{(empty? '(()))} & \#false\\
\end{tabular}
\end{center}
\section{Listenverarbeitung}
\label{sec:org52ea285}
\begin{enumerate}
\item Die Funktion \texttt{enthaelt?} beantworte, angewendet auf ein Symbol und
eine Liste von Symbolen, die Frage, ob das Symbol in der Liste
enthalten ist oder nicht
\begin{minted}[]{scheme}
   ;; Zweckbestimmung s. Aufgabenstellung
   ;;  enthaelt? ; (list-of symbol) symbol -> boolean
   (check-expect (enthaelt? empty 's) #false)
   (check-expect (enthaelt? '(x y z) 's) #false)
   (check-expect (enthaelt? '(s y z) 's) #true)
   (check-expect (enthaelt? '(x y s z) 's) #true)
   
   (define enthaelt?
     (lambda [liste symbol]
       (cond
         [(empty? liste) #false]
         [(equal? (first liste) symbol) #true]
         [else (enthaelt? (rest liste) symbol)])))
\end{minted}
\item Die Funktion \texttt{sum} liefere, angewendet auf eine Liste von Zahlen \texttt{x},
die Summe der Elemente.
Die folgende Lösung erlaubt nur nicht leere Listen von Zahlen:
\begin{minted}[]{scheme}
   ;; Zweckbestimmung s. Aufgabenstellung
   ;;
   ;; Datendefinition:
   ;; Eine Liste-von-Zahlen ist entweder
   ;;  - (cons n empty), wobei n eine Zahl ist oder
   ;;  - (cons n lvz), wobei n eine Zahl und lvz eine Liste-von-Zahlen ist
   ;;
   ;; sum : (list-of number) -> number
	(check-expect (sum '(1)) 1)
	(check-expect (sum '(1 2 3 4)) 10)
	
	(define sum
	  (lambda [lvz]
	    (cond
		  [(empty? (rest lvz)) (first lvz)]
		  [else (+ (first lvz)
		           (sum (rest lvz)))])))
\end{minted}
Die folgende Lösung liefert für leere Listen das neutrale Element
bzgl. der Addition:
\begin{minted}[]{scheme}
   ;; Zweckbestimmung s. Aufgabenstellung
   ;;
   ;; Datendefinition:
   ;; Eine Liste-von-Zahlen ist entweder
   ;;  - enpty
   ;;  - (cons n lvz), wobei n eine Zahl und lvz eine Liste-von-Zahlen ist
   ;;
   ;; sum : (list-of number) -> number
	(check-expect (sum '()) 0)
	(check-expect (sum '(1 2 3 4)) 10)
	
	(define sum
	  (lambda [lvz]
	    (cond
		  [(empty? lvz) 0]
		  [else (+ (first lvz)
		           (sum (rest lvz)))])))
\end{minted}
\item Die Funktion \texttt{prod} liefere, angewendet auf eine Liste von Zahlen
\texttt{x}, das Produkt der Elemente.
Die folgende Lösung erlaubt nur nicht leere Listen von Zahlen:
\begin{minted}[]{scheme}
   ;; Zweckbestimmung s. Aufgabenstellung
   ;;
   ;; Datendefinition:
   ;; Eine Liste-von-Zahlen ist entweder
   ;;  - (cons n empty), wobei n eine Zahl ist oder
   ;;  - (cons n lvz), wobei n eine Zahl und lvz eine Liste-von-Zahlen ist
   ;;
   ;; sum : (list-of number) -> number
	(check-expect (prod '(1)) 1)
	(check-expect (prod '(1 2 3 4)) 24)
	
	(define prod
	  (lambda [lvz]
	    (cond
		  [(empty? (rest lvz)) (first lvz)]
		  [else (* (first lvz)
		           (prod (rest lvz)))])))
\end{minted}
Die folgende Lösung liefert für leere Listen das neutrale Element
bzgl. der Multiplikation:
\begin{minted}[]{scheme}
   ;; Zweckbestimmung s. Aufgabenstellung
   ;;
   ;; Datendefinition:
   ;; Eine Liste-von-Zahlen ist entweder
   ;;  - enpty
   ;;  - (cons n lvz), wobei n eine Zahl und lvz eine Liste-von-Zahlen ist
   ;;
   ;; sum : (list-of number) -> number
	(check-expect (prod '()) 1)
	(check-expect (prod '(1 2 3 4)) 24)
	
	(define prod
	  (lambda [lvz]
	    (cond
		  [(empty? lvz) 1]
		  [else (* (first lvz)
		           (prod (rest lvz)))])))
\end{minted}
\item Die Funktion \texttt{maximum} liefere, angewendet auf eine Liste von Zahlen
\texttt{x}, das Maximum der Elemente.
Die folgende Lösung erlaubt nur nicht leere Listen von Zahlen:
\begin{minted}[]{scheme}
   ;; Zweckbestimmung s. Aufgabenstellung
   ;;
   ;; Datendefinition:
   ;; Eine Liste-von-Zahlen ist entweder
   ;;  - (cons n empty), wobei n eine Zahl ist oder
   ;;  - (cons n lvz), wobei n eine Zahl und lvz eine Liste-von-Zahlen ist
   ;;
   ;; sum : (list-of number) -> number
	(check-expect (maximum '(1)) 1)
	(check-expect (maximum '(1 2 3 0)) 3)
	
	(define maximum
	  (lambda [lvz]
	    (cond
		  [(empty? (rest lvz)) (first lvz)]
		  [else (max (first lvz)
		           (maximum (rest lvz)))])))
\end{minted}
\item Schreiben Sie eine Funktion \texttt{(declist x)}, die aus einer Liste \texttt{x}
von Zahlen eine neue Liste berechnet, deren Elemente um 1 kleiner
sind, als die der ursprünglichen Liste:

\begin{center}
\begin{tabular}{ll}
x & (declist x)\\
\hline
(2 5 7) & (1 4 6)\\
() & ()\\
\end{tabular}
\end{center}
\begin{minted}[]{scheme}
   ;; Zweckbestimmung s. Aufgabenstellung
   ;; declist : (list-of number) -> (list-of number)
   (check-expect (declist empty) empty)
   (check-expect (declist '(2 5 7)) '(1 4 6))
   
   (define declist
     (lambda [lvz]
	   (cond
	     [(empty? lvz) empty]
		 [else (cons (- (first lvz) 1) 
		             (declist (rest lvz)))]
	   )))
\end{minted}
\item Definieren Sie eine Funktion \texttt{(flatten x)}, die als Argument eine
Liste \texttt{x} mit beliebig tief geschachtelten Unterlisten hat und als
Ergebnis eine Liste von Atomen liefern soll mit der Eigenschaft, dass
alle Atome, die in x vorkommen auch in \texttt{(flatten x)} in derselben
Reihenfolge vorkommen:

\begin{center}
\begin{tabular}{ll}
x & (flatten x)\\
\hline
(A (B C) D) & (A B C D)\\
(((A B) C)(D E)) & (A B C D E)\\
((((A)))) & (A)\\
\end{tabular}
\end{center}

\textbf{Hinweis:} Definieren Sie zuerst in der bekannten Art und Weise
eine rekursive Datenstruktur für geschachtelte Listen. Leiten Sie
daraus eine passende \textbf{Funktionsschablone} ab.
\begin{minted}[]{scheme}
   ;; Definition einer beliebig tief geschachtelten Liste (btgl) von Atomen
   ;; Eine btgl ist
   ;; - empty
   ;; - (cons a l) mit a ist ein Atom, l ist eine btgl
   ;; - (cons l1 l2) mit l1, l2 sind btgl
   ;; Funktionsschablone:
   ;(define f
   ;  (lambda [l]
   ;    (cond
   ;      [(empty? l) ...]
   ;      [(not (list? (first l)))
   ;       ... (first l) ... (f (rest l)) ...]
   ;      [else  ... (f (first l)) ... (f (rest l)) ...])))
   ;;
   ;; Zweckbestimmung s. Aufgabenstellung
   ;; flatten : (list-of any) -> (list-of atom)
   (check-expect (flatten empty) empty)
   (check-expect (flatten '(a (b (c (d))))) '(a b c d))
   (check-expect (flatten '((((a) b) c) d)) '(a b c d))
   (define flatten
     (lambda [l]
       (cond
         [(empty? l) empty]
         [(not (list? (first l)))
          (cons (first l) (flatten (rest l)))]
         [else  (append (flatten (first l)) (flatten (rest l)))])))

	;; ;; Konkatiniert die zwei Listen l1 und l2 
	;; ;; append : (list-of any) (list-of any) -> (list-of any)
	;; (check-expect (append empty empty) empty)
	;; (check-expect (append empty '(A B C)) '(A B C))
	;; (check-expect (append '(A B C) empty) '(A B C))
	;; (check-expect (append '(A B C) '(C D E)) '(A B C C D E))
	
	;; (define append
	;;   (lambda [l1 l2]
	;;     (cond
	;; 	  [(empty? l1) l2]
	;; 	  [(empty? l2) l1]
	;; 	  [else (cons (first l1) (append (rest l1) l2))])))
\end{minted}
\item \textbf{Zusatzaufgabe}: Schreiben Sie eine Funktion \texttt{(frequencies x)}, die aus einer Liste
\texttt{x} von Atomen eine Liste von zwei-elementigen Listen erzeugt: Dabei
ist das erste Element das Atom aus \texttt{x}, das zweite Element die
Häufigkeit des Auftretens in \texttt{x}. Die Reihenfolge der Strukturen in
der Ergebnisliste ist belanglos.

\begin{center}
\begin{tabular}{ll}
x & (frequencies x)\\
\hline
(A B A B A C A) & ((A 4) (B 2) (C 1))\\
() & ()\\
\end{tabular}
\end{center}
\begin{minted}[]{scheme}
;; Datenstrukturdefinitionen:
;; Eine Atom-Number-Pair (anp) ist ein
;; - (cons a (cons n empty)) mit a ist Atom und n ist Number
;;
;; Eine Liste von Atomen (loa) ist 
;; - empty oder
;; - (cons a l) mit a ist Atom und l ist loa
;;
;; Eine Liste von Atom-Number-Pairs (loanp) ist
;; - empty oder
;; - (cons a l) mit a ist anp und l ist loanp

;; erhoeht die number im ersten atom-mumber-pair um 1
;; incr-first-number : (list-of atom-number-pair) 
;;                      -> (list-of atom-number-pair)
(check-expect (incr-first-number '((a  5) (b  3) (c  4))) 
              '((a  6) (b  3) (c  4)))
(define incr-first-number 
  (lambda [aloanp]
    (let
        [(firstatom (first (first aloanp)))
         (firstnumber (first (rest (first aloanp))))
         (rest-anps (rest aloanp))]
      (cons (list firstatom (+ 1 firstnumber)) rest-anps))))

;;; Version von incr-first-number ohne lokale Definitionen
;(define incr-first-number 
;  (lambda [aloanp]
;    (cons (list (first (first aloanp)) 
;                (+ 1 (first (rest (first aloanp))))) (rest aloanp))))

;; prueft, ob das Atom in der Liste vorkommt:
;; - falls ja ist die number im entsprechenden pair zu inkrementieren
;; - falls nein ist der Liste ein neues pair "(atom  1)" hinzuzufuegen
;; add-atom : atom (list-of atom-number-pair) 
;;                 -> (list-of atom-number-pair)))
(check-expect (add-atom 'a empty)  '((a  1)))
(check-expect (add-atom 'a '((a  1) (b  1))) '((a  2) (b  1)))
(check-expect (add-atom 'a '((b  1))) '((b  1) (a  1)))
(define add-atom
  (lambda [atom aloanp]
    (cond
      [(empty? aloanp) (cons (list atom 1) empty)]
      [(equal? atom (first (first aloanp))) 
       (incr-first-number aloanp)]
      [else (cons (first aloanp) (add-atom atom (rest aloanp)))])))
   
;; Zweckbestimmung s. Aufgabenblatt
;; frequencies : (list-of atom) ->  (list-of atom-number-pair)
(check-expect (frequencies empty) empty) 
(check-expect (frequencies '(a)) '((a  1)))
(check-expect (frequencies '(A B A B A C A)) '((A  4) (C  1) (B  2)))
(define frequencies
  (lambda [aloa]
    (cond
      [(empty? aloa) empty]
      [else
       (add-atom (first aloa) (frequencies (rest aloa)))])))   
\end{minted}
\item Schreiben Sie eine Funktion \texttt{anzahl-bevor-summe-erreicht}, die eine
positive ganze Zahl, genannt \texttt{summe} und eine Liste von positiven
ganzen Zahlen, genannt \texttt{lvz} als Argumente akzeptiert. Sie gibt
eine ganze Zahl \(n\) zurück, so dass die Summe der ersten \(n\)
Elemente von \texttt{lvz} kleiner als \texttt{sum},  die Summe der ersten \(n+1\)
Elemente hingegen größer oder gleich \texttt{sum} ist. Es ist ein Fehler,
wenn die Summe der Elemente der Liste insgesamt kleiner als sum
ist.\\
Beispiele:\\
\begin{center}
\begin{tabular}{rlr}
sum & lvz & (anzahl-bevor-summe-erreicht sum lvz)\\
\hline
2 & (2 5 7) & 0\\
4 & (2 5 7) & 1\\
8 & (2 5 7) & 2\\
15 & (2 5 7) & Fehler\\
\end{tabular}
\end{center}

\textbf{Hinweise:} 
\begin{enumerate}
\item Für den Fehlerfall darf die Standardfunktion \texttt{error}
benutzt werden. Sie erwartet zwei Argumente, ein Symbol und eine
Zeichenkette und könnte z. B. so benutzt werden:
\begin{verbatim}
(error 'anzahl-bevor-summe-erreicht "Summe der Listenelemente zu klein")
\end{verbatim}
\item Lösen Sie die Aufgabe, ohne die Summe der Listenelemente zu berechnen.
\end{enumerate}
\begin{minted}[]{scheme}
   ;; Zweckbestimmung s. Aufgabenstellung
   ; anzahl-bevor-summe-erreicht: number (list-of number) -> number
   (check-expect (anzahl-bevor-summe-erreicht 2 '(2 5 7)) 0)
   (check-expect (anzahl-bevor-summe-erreicht 4 '(2 5 7)) 1)
   (check-expect (anzahl-bevor-summe-erreicht 8 '(2 5 7)) 2)
   (check-error 
       (anzahl-bevor-summe-erreicht 15 '(2 5 7))
       "anzahl-bevor-summe-erreicht: Summe der Listenelemente zu klein")
   (define anzahl-bevor-summe-erreicht
     (lambda [sum lvz]
       (cond
         [(empty? lvz) (error 
                          'anzahl-bevor-summe-erreicht 
                          "Summe der Listenelemente zu klein")]
         [(<= sum (first lvz)) 0]
         [else (+ 1 (anzahl-bevor-summe-erreicht
                     (- sum (first lvz))
                     (rest lvz)))])))
\end{minted}
\item Gegeben sei die Datenstrukturdefinition \texttt{gast} aus Aufgabe 12 und z.~B.
die folgende Gästeliste:
\begin{minted}[]{scheme}
(define party
  (list
    (make-gast "Karl" #false #false)
    (make-gast "Rosa" #true #true)
    (make-gast "Klara" #true #false) 
    (make-gast "Egon" #false #true)))
\end{minted}
\begin{enumerate}
\item Schreiben Sie eine Funktion \texttt{vegetarier}, die aus einer
Gästeliste eine Liste der Vegetarier bildet. Für die Liste
\texttt{party} müsste sie dieses Ergebnis liefern:
\begin{minted}[]{scheme}
(list (make-gast "Rosa" #true #true)
      (make-gast "Egon" #false #true))
\end{minted}
\item Schreiben Sie eine Funktion \texttt{frauen}, die aus einer Gästeliste
eine Liste mit den weiblichen Gästen bildet.
\end{enumerate}
\begin{minted}[]{scheme}
; Ein Gast besteht aus
; - einer Zeichenkette für den Namen
; - einem boolschen Wert, der angibt ob es sich um eine Frau handelt
; - einem boolschen Wert, der angibt ob es sich um einen Vegetarier handelt

(define-struct gast [name weiblich? vegetarier?])

; aus einer Gästeliste eine Liste der Vegetarier bilden
;; vegetarier: (list-of gast) -> (list-of gast)
(check-expect (vegetarier party) (list (make-gast "Rosa" #true #true)
                                       (make-gast "Egon" #false #true)))

(define vegetarier
  (lambda [gaeste]
    (cond
      [(empty? gaeste) empty]
      [(gast-vegetarier? (first gaeste))
       (cons (first gaeste)
             (vegetarier (rest gaeste)))]
      [else (vegetarier (rest gaeste))])))

; aus einer Gästeliste eine Liste der Frauen bilden
;; frauen: (list-of gast) -> (list-of gast)
(check-expect (frauen party) (list (make-gast "Rosa" #true #true)
                                   (make-gast "Klara" #true #false)))
(define frauen
  (lambda [gaeste]
    (cond
      [(empty? gaeste) empty]
      [(gast-weiblich? (first gaeste))
       (cons (first gaeste)
             (frauen (rest gaeste)))]
      [else (frauen (rest gaeste))])))
\end{minted}
\end{enumerate}
\section{Funktionen über zwei Listen}
\label{sec:org0d199cc}
Die in den folgenden Aufgaben zu entwickelnden Funktionen haben alle 2
Listen-Parameter. Lösen Sie diese Aufgaben unter Anwendung der Regeln
11 bis 13. Überlegen Sie dabei, ob für die Erstellung der
Funktionsschablone der Zugriff auf das erste Element und die Restliste
hinsichtlich des ersten, des zweiten oder beider Parameter vorgenommen
werden muss.

\begin{enumerate}
\item Schreiben Sie ein Funktion \texttt{concatenate}, die zwei Listen von
Symbolen aneinander hängt. Beispiel:
\begin{verbatim}
(concatenate ’(a b c) ’(d e f)) => ’(a b c d e f)
\end{verbatim}

\begin{minted}[]{scheme}
   ;; Zweckbestimmung s. Aufgabenstellung
   ;; 
   ;; Datendefinition
   ;; Eine Liste-von-Symbolen ist entweder
   ;;  1. empty oder
   ;;  2. (cons s lvs), wobei s ein Symbol 
   ;;                   und lvs eine Liste-von-Symbolen ist
   ;; 
   ;; concatenate : (list-of symbol) (list-of symbol) -> (list-of symbol)

   (check-expect (concatenate ’(a b c) ’(d e f)) ’(a b c d e f))
   (check-expect (concatenate ’() ’(d e f)) ’(d e f))
   (check-expect (concatenate ’(a b c) ’()) ’(a b c))

   (define concatenate
	  (lambda [l1 l2]
	    (cond
		  [(empty? l1) l2]
		  [(empty? l2) l1]
		  [else (cons (first l1)
		              (concatenate (rest l1) l2))])))
\end{minted}
\item Schreiben Sie eine Funktion \texttt{mult-2-num-lists}, die zwei gleich lange
Listen mit Zahlen zu einer Liste verarbeitet, die die Produkte der
korrespondierenden Elemente der Argumentlisten enthält. Beispiel:
\begin{verbatim}
(mult-2-num-lists ’(2 3 4) ’(7 8 9)) => ’(14 24 36)
\end{verbatim}

\begin{minted}[]{scheme}
   ;; Zweckbestimmung s. Aufgabenstellung
   ;; 
   ;; Datendefinition
   ;; Eine Liste-von-Zahlen ist entweder
   ;;  1. empty oder
   ;;  2. (cons z lvz), wobei z eine Zahl 
   ;;                   und lvz eine Liste-von-Zahlen ist
   ;; 
   ;; mult-2-num-lists : (list-of number) (list-of number) -> (list-of number)

   (check-expect (mult-2-num-lists '(2 3 4) '(7 8 9)) '(14 24 36))
   (check-expect (mult-2-num-lists '() '()) '())

   (define mult-2-num-lists
	  (lambda [l1 l2]
	    (cond
		  [(empty? l1) empty]
		  [else (cons (* (first l1) (first l2))
		              (mult-2-num-lists (rest l1) (rest l2)))])))
\end{minted}
\item Entwickeln Sie eine Funktion \texttt{merge}, die 2 Listen von Zahlen
verarbeitet, die aufsteigend sortiert sind. Sie liefert eine
sortierte Liste von Zahlen, die alle Zahlen aus den beiden
Argumentlisten enthält. Wenn Zahlen in den Argumentliste mehrfach
vorkommen, sollen Sie auch in der Ergebnisliste entsprechend oft
auftauchen. Beispiel:
\begin{verbatim}
(merge ’(2 5 7) ’(1 3 5 9)) => ’(1 2 3 5 5 7 9)
\end{verbatim}

\begin{minted}[]{scheme}
   ;; Zweckbestimmung s. Aufgabenstellung
   ;; 
   ;; Datendefinition
   ;; Eine Liste-von-Zahlen ist entweder
   ;;  1. empty oder
   ;;  2. (cons z lvz), wobei z eine Zahl 
   ;;                   und lvz eine Liste-von-Zahlen ist
   ;; 
   ;; merge : (list-of number) (list-of number) -> (list-of number)

   (check-expect (merge '(2 3 4 11) '(1 4 7 8 9)) '(1 2 3 4 4 7 8 9 11))
   (check-expect (merge '() '()) '())

   (define merge
	  (lambda [l1 l2]
	    (cond
		  [(empty? l1) l2]
		  [(empty? l2) l1]
		  [(< (first l1) (first l2)) (cons (first l1) 
                                                   (merge (rest l1) l2))]
		  [else (cons (first l2) (merge l1 (rest l2)))])))
\end{minted}
\end{enumerate}
\end{document}